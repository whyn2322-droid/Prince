# Auto-generated single actions module (bundled from multiple files)
import types
import importlib
from typing import Any

def _load_module(name: str, src: str):
    mod = types.ModuleType(name)
    exec(compile(src, name, "exec"), mod.__dict__)
    return mod

_SRC_1 = 'from __future__ import annotations\n\nimport math\nimport re\nfrom typing import Any, Dict, List, Optional, Text\n\nfrom rasa_sdk import Action, FormValidationAction, Tracker\nfrom rasa_sdk.events import AllSlotsReset, FollowupAction\nfrom rasa_sdk.executor import CollectingDispatcher\nfrom rasa_sdk.types import DomainDict\n\nNUMBER_PATTERN = re.compile(r"-?\\d+(?:[.,]\\d+)?")\n\nSHAPE_SYNONYMS = {\n    "circle": {"circle", "тойрог", "тойргийн", "дугуй"},\n    "rectangle": {"rectangle", "тэгш өнцөгт", "тэгш өнцөгтийн"},\n    "square": {"square", "дөрвөлжин", "квадрат"},\n    "triangle": {"triangle", "гурвалжин", "гурвалжны"},\n}\n\nSHAPE_LABELS = {\n    "circle": "тойрог",\n    "rectangle": "тэгш өнцөгт",\n    "square": "дөрвөлжин",\n    "triangle": "гурвалжин",\n}\n\n\ndef normalize_shape(value: Optional[Text]) -> Optional[Text]:\n    if not value:\n        return None\n    text = value.strip().lower()\n    for shape, synonyms in SHAPE_SYNONYMS.items():\n        if text == shape or text in synonyms:\n            return shape\n    for shape, synonyms in SHAPE_SYNONYMS.items():\n        for synonym in synonyms:\n            if synonym in text:\n                return shape\n    return None\n\n\ndef parse_positive_number(value: Any) -> Optional[float]:\n    if value is None:\n        return None\n    if isinstance(value, (int, float)):\n        number = float(value)\n    else:\n        match = NUMBER_PATTERN.search(str(value))\n        if not match:\n            return None\n        number = float(match.group(0).replace(",", "."))\n    if number <= 0:\n        return None\n    return number\n\n\nclass ValidatePerimeterForm(FormValidationAction):\n    def name(self) -> Text:\n        return "validate_perimeter_form"\n\n    async def required_slots(\n        self,\n        slots_mapped_in_domain: List[Text],\n        dispatcher: CollectingDispatcher,\n        tracker: Tracker,\n        domain: DomainDict,\n    ) -> List[Text]:\n        shape = normalize_shape(tracker.get_slot("shape"))\n        if shape == "circle":\n            return ["shape", "radius"]\n        if shape == "rectangle":\n            return ["shape", "width", "height"]\n        if shape == "square":\n            return ["shape", "square_side"]\n        if shape == "triangle":\n            return ["shape", "side_a", "side_b", "side_c"]\n        return ["shape"]\n\n    def validate_shape(\n        self,\n        value: Text,\n        dispatcher: CollectingDispatcher,\n        tracker: Tracker,\n        domain: DomainDict,\n    ) -> Dict[Text, Any]:\n        shape = normalize_shape(value)\n        if shape:\n            return {"shape": shape}\n        dispatcher.utter_message(response="utter_invalid_shape")\n        return {"shape": None}\n\n    def validate_radius(\n        self,\n        value: Text,\n        dispatcher: CollectingDispatcher,\n        tracker: Tracker,\n        domain: DomainDict,\n    ) -> Dict[Text, Any]:\n        number = parse_positive_number(value)\n        if number is not None:\n            return {"radius": number}\n        dispatcher.utter_message(response="utter_invalid_number")\n        return {"radius": None}\n\n    def validate_width(\n        self,\n        value: Text,\n        dispatcher: CollectingDispatcher,\n        tracker: Tracker,\n        domain: DomainDict,\n    ) -> Dict[Text, Any]:\n        number = parse_positive_number(value)\n        if number is not None:\n            return {"width": number}\n        dispatcher.utter_message(response="utter_invalid_number")\n        return {"width": None}\n\n    def validate_height(\n        self,\n        value: Text,\n        dispatcher: CollectingDispatcher,\n        tracker: Tracker,\n        domain: DomainDict,\n    ) -> Dict[Text, Any]:\n        number = parse_positive_number(value)\n        if number is not None:\n            return {"height": number}\n        dispatcher.utter_message(response="utter_invalid_number")\n        return {"height": None}\n\n    def validate_square_side(\n        self,\n        value: Text,\n        dispatcher: CollectingDispatcher,\n        tracker: Tracker,\n        domain: DomainDict,\n    ) -> Dict[Text, Any]:\n        number = parse_positive_number(value)\n        if number is not None:\n            return {"square_side": number}\n        dispatcher.utter_message(response="utter_invalid_number")\n        return {"square_side": None}\n\n    def validate_side_a(\n        self,\n        value: Text,\n        dispatcher: CollectingDispatcher,\n        tracker: Tracker,\n        domain: DomainDict,\n    ) -> Dict[Text, Any]:\n        number = parse_positive_number(value)\n        if number is not None:\n            return {"side_a": number}\n        dispatcher.utter_message(response="utter_invalid_number")\n        return {"side_a": None}\n\n    def validate_side_b(\n        self,\n        value: Text,\n        dispatcher: CollectingDispatcher,\n        tracker: Tracker,\n        domain: DomainDict,\n    ) -> Dict[Text, Any]:\n        number = parse_positive_number(value)\n        if number is not None:\n            return {"side_b": number}\n        dispatcher.utter_message(response="utter_invalid_number")\n        return {"side_b": None}\n\n    def validate_side_c(\n        self,\n        value: Text,\n        dispatcher: CollectingDispatcher,\n        tracker: Tracker,\n        domain: DomainDict,\n    ) -> Dict[Text, Any]:\n        number = parse_positive_number(value)\n        if number is not None:\n            return {"side_c": number}\n        dispatcher.utter_message(response="utter_invalid_number")\n        return {"side_c": None}\n\n\nclass ActionCalculatePerimeter(Action):\n    def name(self) -> Text:\n        return "action_calculate_perimeter"\n\n    def run(\n        self,\n        dispatcher: CollectingDispatcher,\n        tracker: Tracker,\n        domain: DomainDict,\n    ) -> List[Dict[Text, Any]]:\n        shape = normalize_shape(tracker.get_slot("shape"))\n        if not shape:\n            dispatcher.utter_message(response="utter_invalid_shape")\n            return []\n\n        perimeter = None\n        details = None\n        if shape == "circle":\n            radius = tracker.get_slot("radius")\n            if radius is not None:\n                perimeter = 2 * math.pi * radius\n                details = (\n                    "Томьёо: P = 2 * pi * радиус\\n"\n                    f"Тооцоолол: P = 2 * {math.pi:.4f} * {radius:.2f} = {perimeter:.2f}"\n                )\n        elif shape == "rectangle":\n            width = tracker.get_slot("width")\n            height = tracker.get_slot("height")\n            if width is not None and height is not None:\n                perimeter = 2 * (width + height)\n                details = (\n                    "Томьёо: P = 2(урт + өргөн)\\n"\n                    f"Тооцоолол: P = 2({width:.2f} + {height:.2f}) = {perimeter:.2f}"\n                )\n        elif shape == "square":\n            side = tracker.get_slot("square_side")\n            if side is not None:\n                perimeter = 4 * side\n                details = (\n                    "Томьёо: P = 4 * тал\\n"\n                    f"Тооцоолол: P = 4 * {side:.2f} = {perimeter:.2f}"\n                )\n        elif shape == "triangle":\n            side_a = tracker.get_slot("side_a")\n            side_b = tracker.get_slot("side_b")\n            side_c = tracker.get_slot("side_c")\n            if side_a is not None and side_b is not None and side_c is not None:\n                perimeter = side_a + side_b + side_c\n                details = (\n                    "Томьёо: P = a + b + c\\n"\n                    f"Тооцоолол: P = {side_a:.2f} + {side_b:.2f} + {side_c:.2f} = {perimeter:.2f}"\n                )\n\n        if perimeter is None:\n            dispatcher.utter_message(text="Дутуу утга байна. Дахин оролдоно уу.")\n            return []\n\n        label = SHAPE_LABELS.get(shape, "дүрс")\n        dispatcher.utter_message(text=f"{label} дүрсний хүрээ {perimeter:.2f} байна.")\n        if details:\n            dispatcher.utter_message(text=details)\n        return [AllSlotsReset(), FollowupAction("perimeter_form")]\n'
_mod_1 = _load_module('_actions_part_1_grade_10_12_part3_extra_actions', _SRC_1)
_SRC_2 = 'from __future__ import annotations\n\nimport math\nimport re\nfrom typing import Any, Dict, List, Optional, Text\n\nfrom rasa_sdk import Action, FormValidationAction, Tracker\nfrom rasa_sdk.events import AllSlotsReset, FollowupAction\nfrom rasa_sdk.executor import CollectingDispatcher\nfrom rasa_sdk.types import DomainDict\n\nNUMBER_PATTERN = re.compile(r"-?\\d+(?:[.,]\\d+)?")\n\nSHAPE_SYNONYMS = {\n    "circle": {"circle", "тойрог", "тойргийн", "дугуй"},\n    "rectangle": {"rectangle", "тэгш өнцөгт", "тэгш өнцөгтийн"},\n    "square": {"square", "дөрвөлжин", "квадрат"},\n    "triangle": {"triangle", "гурвалжин", "гурвалжны"},\n}\n\nSHAPE_LABELS = {\n    "circle": "тойрог",\n    "rectangle": "тэгш өнцөгт",\n    "square": "дөрвөлжин",\n    "triangle": "гурвалжин",\n}\n\n\ndef normalize_shape(value: Optional[Text]) -> Optional[Text]:\n    if not value:\n        return None\n    text = value.strip().lower()\n    for shape, synonyms in SHAPE_SYNONYMS.items():\n        if text == shape or text in synonyms:\n            return shape\n    for shape, synonyms in SHAPE_SYNONYMS.items():\n        for synonym in synonyms:\n            if synonym in text:\n                return shape\n    return None\n\n\ndef parse_positive_number(value: Any) -> Optional[float]:\n    if value is None:\n        return None\n    if isinstance(value, (int, float)):\n        number = float(value)\n    else:\n        match = NUMBER_PATTERN.search(str(value))\n        if not match:\n            return None\n        number = float(match.group(0).replace(",", "."))\n    if number <= 0:\n        return None\n    return number\n\n\nclass ValidatePerimeterForm(FormValidationAction):\n    def name(self) -> Text:\n        return "validate_perimeter_form"\n\n    async def required_slots(\n        self,\n        slots_mapped_in_domain: List[Text],\n        dispatcher: CollectingDispatcher,\n        tracker: Tracker,\n        domain: DomainDict,\n    ) -> List[Text]:\n        shape = normalize_shape(tracker.get_slot("shape"))\n        if shape == "circle":\n            return ["shape", "radius"]\n        if shape == "rectangle":\n            return ["shape", "width", "height"]\n        if shape == "square":\n            return ["shape", "square_side"]\n        if shape == "triangle":\n            return ["shape", "side_a", "side_b", "side_c"]\n        return ["shape"]\n\n    def validate_shape(\n        self,\n        value: Text,\n        dispatcher: CollectingDispatcher,\n        tracker: Tracker,\n        domain: DomainDict,\n    ) -> Dict[Text, Any]:\n        shape = normalize_shape(value)\n        if shape:\n            return {"shape": shape}\n        dispatcher.utter_message(response="utter_invalid_shape")\n        return {"shape": None}\n\n    def validate_radius(\n        self,\n        value: Text,\n        dispatcher: CollectingDispatcher,\n        tracker: Tracker,\n        domain: DomainDict,\n    ) -> Dict[Text, Any]:\n        number = parse_positive_number(value)\n        if number is not None:\n            return {"radius": number}\n        dispatcher.utter_message(response="utter_invalid_number")\n        return {"radius": None}\n\n    def validate_width(\n        self,\n        value: Text,\n        dispatcher: CollectingDispatcher,\n        tracker: Tracker,\n        domain: DomainDict,\n    ) -> Dict[Text, Any]:\n        number = parse_positive_number(value)\n        if number is not None:\n            return {"width": number}\n        dispatcher.utter_message(response="utter_invalid_number")\n        return {"width": None}\n\n    def validate_height(\n        self,\n        value: Text,\n        dispatcher: CollectingDispatcher,\n        tracker: Tracker,\n        domain: DomainDict,\n    ) -> Dict[Text, Any]:\n        number = parse_positive_number(value)\n        if number is not None:\n            return {"height": number}\n        dispatcher.utter_message(response="utter_invalid_number")\n        return {"height": None}\n\n    def validate_square_side(\n        self,\n        value: Text,\n        dispatcher: CollectingDispatcher,\n        tracker: Tracker,\n        domain: DomainDict,\n    ) -> Dict[Text, Any]:\n        number = parse_positive_number(value)\n        if number is not None:\n            return {"square_side": number}\n        dispatcher.utter_message(response="utter_invalid_number")\n        return {"square_side": None}\n\n    def validate_side_a(\n        self,\n        value: Text,\n        dispatcher: CollectingDispatcher,\n        tracker: Tracker,\n        domain: DomainDict,\n    ) -> Dict[Text, Any]:\n        number = parse_positive_number(value)\n        if number is not None:\n            return {"side_a": number}\n        dispatcher.utter_message(response="utter_invalid_number")\n        return {"side_a": None}\n\n    def validate_side_b(\n        self,\n        value: Text,\n        dispatcher: CollectingDispatcher,\n        tracker: Tracker,\n        domain: DomainDict,\n    ) -> Dict[Text, Any]:\n        number = parse_positive_number(value)\n        if number is not None:\n            return {"side_b": number}\n        dispatcher.utter_message(response="utter_invalid_number")\n        return {"side_b": None}\n\n    def validate_side_c(\n        self,\n        value: Text,\n        dispatcher: CollectingDispatcher,\n        tracker: Tracker,\n        domain: DomainDict,\n    ) -> Dict[Text, Any]:\n        number = parse_positive_number(value)\n        if number is not None:\n            return {"side_c": number}\n        dispatcher.utter_message(response="utter_invalid_number")\n        return {"side_c": None}\n\n\nclass ActionCalculatePerimeter(Action):\n    def name(self) -> Text:\n        return "action_calculate_perimeter"\n\n    def run(\n        self,\n        dispatcher: CollectingDispatcher,\n        tracker: Tracker,\n        domain: DomainDict,\n    ) -> List[Dict[Text, Any]]:\n        shape = normalize_shape(tracker.get_slot("shape"))\n        if not shape:\n            dispatcher.utter_message(response="utter_invalid_shape")\n            return []\n\n        perimeter = None\n        details = None\n        if shape == "circle":\n            radius = tracker.get_slot("radius")\n            if radius is not None:\n                perimeter = 2 * math.pi * radius\n                details = (\n                    "Томьёо: P = 2 * pi * радиус\\n"\n                    f"Тооцоолол: P = 2 * {math.pi:.4f} * {radius:.2f} = {perimeter:.2f}"\n                )\n        elif shape == "rectangle":\n            width = tracker.get_slot("width")\n            height = tracker.get_slot("height")\n            if width is not None and height is not None:\n                perimeter = 2 * (width + height)\n                details = (\n                    "Томьёо: P = 2(урт + өргөн)\\n"\n                    f"Тооцоолол: P = 2({width:.2f} + {height:.2f}) = {perimeter:.2f}"\n                )\n        elif shape == "square":\n            side = tracker.get_slot("square_side")\n            if side is not None:\n                perimeter = 4 * side\n                details = (\n                    "Томьёо: P = 4 * тал\\n"\n                    f"Тооцоолол: P = 4 * {side:.2f} = {perimeter:.2f}"\n                )\n        elif shape == "triangle":\n            side_a = tracker.get_slot("side_a")\n            side_b = tracker.get_slot("side_b")\n            side_c = tracker.get_slot("side_c")\n            if side_a is not None and side_b is not None and side_c is not None:\n                perimeter = side_a + side_b + side_c\n                details = (\n                    "Томьёо: P = a + b + c\\n"\n                    f"Тооцоолол: P = {side_a:.2f} + {side_b:.2f} + {side_c:.2f} = {perimeter:.2f}"\n                )\n\n        if perimeter is None:\n            dispatcher.utter_message(text="Дутуу утга байна. Дахин оролдоно уу.")\n            return []\n\n        label = SHAPE_LABELS.get(shape, "дүрс")\n        dispatcher.utter_message(text=f"{label} дүрсний хүрээ {perimeter:.2f} байна.")\n        if details:\n            dispatcher.utter_message(text=details)\n        return [AllSlotsReset(), FollowupAction("perimeter_form")]\n'
_mod_2 = _load_module('_actions_part_2_grade_1_3_actions', _SRC_2)
_SRC_3 = 'import math\nfrom typing import Any, Dict, List\n\nfrom rasa_sdk import Action, Tracker\nfrom rasa_sdk.events import SlotSet\nfrom rasa_sdk.executor import CollectingDispatcher\n\n\ndef _parse_numbers(text: str) -> List[float]:\n    if not text:\n        return []\n    cleaned = []\n    allowed = set("0123456789.-")\n    for ch in text:\n        cleaned.append(ch if ch in allowed else " ")\n    numbers: List[float] = []\n    for part in "".join(cleaned).split():\n        try:\n            numbers.append(float(part))\n        except ValueError:\n            continue\n    return numbers\n\n\nclass ActionAskSquareSide(Action):\n    def name(self) -> str:\n        return "action_ask_square_side"\n\n    def run(\n        self,\n        dispatcher: CollectingDispatcher,\n        tracker: Tracker,\n        domain: Dict[str, Any],\n    ) -> List[Dict[str, Any]]:\n        dispatcher.utter_message(response="utter_ask_square_side")\n        return [SlotSet("pending_calc", "square_area"), SlotSet("pending_topic", None)]\n\n\nclass ActionAskRectangleSides(Action):\n    def name(self) -> str:\n        return "action_ask_rectangle_sides"\n\n    def run(\n        self,\n        dispatcher: CollectingDispatcher,\n        tracker: Tracker,\n        domain: Dict[str, Any],\n    ) -> List[Dict[str, Any]]:\n        dispatcher.utter_message(response="utter_ask_rectangle_sides")\n        return [SlotSet("pending_calc", "rectangle_area"), SlotSet("pending_topic", None)]\n\n\nclass ActionAskCubeSide(Action):\n    def name(self) -> str:\n        return "action_ask_cube_side"\n\n    def run(\n        self,\n        dispatcher: CollectingDispatcher,\n        tracker: Tracker,\n        domain: Dict[str, Any],\n    ) -> List[Dict[str, Any]]:\n        dispatcher.utter_message(response="utter_ask_cube_side")\n        return [SlotSet("pending_calc", "cube_volume"), SlotSet("pending_topic", None)]\n\n\nclass ActionAskSphereRadius(Action):\n    def name(self) -> str:\n        return "action_ask_sphere_radius"\n\n    def run(\n        self,\n        dispatcher: CollectingDispatcher,\n        tracker: Tracker,\n        domain: Dict[str, Any],\n    ) -> List[Dict[str, Any]]:\n        dispatcher.utter_message(response="utter_ask_sphere_radius")\n        return [SlotSet("pending_calc", "sphere_volume"), SlotSet("pending_topic", None)]\n\n\nclass ActionAskConeParams(Action):\n    def name(self) -> str:\n        return "action_ask_cone_params"\n\n    def run(\n        self,\n        dispatcher: CollectingDispatcher,\n        tracker: Tracker,\n        domain: Dict[str, Any],\n    ) -> List[Dict[str, Any]]:\n        dispatcher.utter_message(response="utter_ask_cone_params")\n        return [SlotSet("pending_calc", "cone_volume"), SlotSet("pending_topic", None)]\n\n\nclass ActionAskCylinderParams(Action):\n    def name(self) -> str:\n        return "action_ask_cylinder_params"\n\n    def run(\n        self,\n        dispatcher: CollectingDispatcher,\n        tracker: Tracker,\n        domain: Dict[str, Any],\n    ) -> List[Dict[str, Any]]:\n        dispatcher.utter_message(response="utter_ask_cylinder_params")\n        return [SlotSet("pending_calc", "cylinder_volume"), SlotSet("pending_topic", None)]\n\n\nclass ActionHandleMeasurements(Action):\n    def name(self) -> str:\n        return "action_handle_measurements"\n\n    def run(\n        self,\n        dispatcher: CollectingDispatcher,\n        tracker: Tracker,\n        domain: Dict[str, Any],\n    ) -> List[Dict[str, Any]]:\n        pending = tracker.get_slot("pending_calc")\n        numbers = _parse_numbers(tracker.latest_message.get("text", ""))\n\n        if not pending:\n            dispatcher.utter_message(response="utter_ask_calc_type")\n            return []\n\n        if pending == "square_area":\n            if len(numbers) < 1:\n                dispatcher.utter_message(response="utter_ask_square_side")\n                return []\n            side = numbers[0]\n            if side <= 0:\n                dispatcher.utter_message(text="Талын урт 0-ээс их байх хэрэгтэй.")\n                return []\n            area = side * side\n            dispatcher.utter_message(\n                text=f"Квадратын талбай: S = a^2 = {side}^2 = {area}"\n            )\n            return [SlotSet("pending_calc", None), SlotSet("pending_topic", None)]\n\n        if pending == "rectangle_area":\n            if len(numbers) < 2:\n                dispatcher.utter_message(response="utter_ask_rectangle_sides")\n                return []\n            length, width = numbers[0], numbers[1]\n            if length <= 0 or width <= 0:\n                dispatcher.utter_message(text="Урт ба өргөн 0-ээс их байх хэрэгтэй.")\n                return []\n            area = length * width\n            dispatcher.utter_message(\n                text=(\n                    f"Тэгш өнцөгтийн талбай: "\n                    f"S = a*b = {length}*{width} = {area}"\n                )\n            )\n            return [SlotSet("pending_calc", None), SlotSet("pending_topic", None)]\n\n        if pending == "cube_volume":\n            if len(numbers) < 1:\n                dispatcher.utter_message(response="utter_ask_cube_side")\n                return []\n            side = numbers[0]\n            if side <= 0:\n                dispatcher.utter_message(text="Талын урт 0-ээс их байх хэрэгтэй.")\n                return []\n            volume = side ** 3\n            dispatcher.utter_message(\n                text=f"Кубын эзэлхүүн: V = a^3 = {side}^3 = {volume}"\n            )\n            return [SlotSet("pending_calc", None), SlotSet("pending_topic", None)]\n\n        if pending == "sphere_volume":\n            if len(numbers) < 1:\n                dispatcher.utter_message(response="utter_ask_sphere_radius")\n                return []\n            radius = numbers[0]\n            if radius <= 0:\n                dispatcher.utter_message(text="Радиус 0-ээс их байх хэрэгтэй.")\n                return []\n            volume = (4.0 / 3.0) * math.pi * (radius ** 3)\n            dispatcher.utter_message(\n                text=(\n                    f"Бөмбөрцгийн эзэлхүүн: "\n                    f"V = 4/3*pi*r^3 = {volume}"\n                )\n            )\n            return [SlotSet("pending_calc", None), SlotSet("pending_topic", None)]\n\n        if pending == "cone_volume":\n            if len(numbers) < 2:\n                dispatcher.utter_message(response="utter_ask_cone_params")\n                return []\n            radius, height = numbers[0], numbers[1]\n            if radius <= 0 or height <= 0:\n                dispatcher.utter_message(text="Радиус ба өндөр 0-ээс их байх хэрэгтэй.")\n                return []\n            volume = (1.0 / 3.0) * math.pi * (radius ** 2) * height\n            dispatcher.utter_message(\n                text=(\n                    f"Конусын эзэлхүүн: "\n                    f"V = 1/3*pi*r^2*h = {volume}"\n                )\n            )\n            return [SlotSet("pending_calc", None), SlotSet("pending_topic", None)]\n\n        if pending == "cylinder_volume":\n            if len(numbers) < 2:\n                dispatcher.utter_message(response="utter_ask_cylinder_params")\n                return []\n            radius, height = numbers[0], numbers[1]\n            if radius <= 0 or height <= 0:\n                dispatcher.utter_message(text="Радиус ба өндөр 0-ээс их байх хэрэгтэй.")\n                return []\n            volume = math.pi * (radius ** 2) * height\n            dispatcher.utter_message(\n                text=(\n                    f"Цилиндрийн эзэлхүүн: "\n                    f"V = pi*r^2*h = {volume}"\n                )\n            )\n            return [SlotSet("pending_calc", None), SlotSet("pending_topic", None)]\n\n        dispatcher.utter_message(response="utter_ask_calc_type")\n        return []\n'
_mod_3 = _load_module('_actions_part_3_grade_4_6_actions', _SRC_3)
_SRC_4 = 'from __future__ import annotations\n\nimport math\nimport re\nfrom typing import Any, Dict, List, Optional, Text, Tuple\n\nfrom rasa_sdk import Action, Tracker\nfrom rasa_sdk.executor import CollectingDispatcher\nfrom sympy import I, factor, expand, simplify\nfrom sympy.parsing.sympy_parser import (\n    convert_xor,\n    implicit_multiplication_application,\n    parse_expr,\n    standard_transformations,\n)\nfrom sympy.simplify.radsimp import radsimp\n\nEPSILON = 1e-9\nNUMBER_RE = re.compile(r"-?\\d+(?:[.,]\\d+)?")\nTRANSFORMATIONS = standard_transformations + (\n    implicit_multiplication_application,\n    convert_xor,\n)\n\n\ndef parse_numbers(text: Text) -> List[float]:\n    return [float(n.replace(",", ".")) for n in NUMBER_RE.findall(text)]\n\n\ndef format_number(value: float) -> str:\n    if abs(value - round(value)) < EPSILON:\n        return str(int(round(value)))\n    return f"{value:.4f}".rstrip("0").rstrip(".")\n\n\ndef format_fraction(numerator: int, denominator: int) -> str:\n    gcd_value = math.gcd(numerator, denominator)\n    numerator //= gcd_value\n    denominator //= gcd_value\n    return f"{numerator}/{denominator} (~{numerator / denominator:.4f})"\n\n\ndef parse_named_coefficients(text: Text) -> Dict[Text, float]:\n    coeffs: Dict[Text, float] = {}\n    for name in ("a", "b", "c"):\n        match = re.search(\n            rf"\\b{name}\\s*[:=]\\s*(-?\\d+(?:[.,]\\d+)?)",\n            text,\n            flags=re.IGNORECASE,\n        )\n        if match:\n            coeffs[name] = float(match.group(1).replace(",", "."))\n    return coeffs\n\n\ndef parse_quadratic_coeffs(text: Text) -> Optional[Tuple[float, float, float]]:\n    named = parse_named_coefficients(text)\n    if all(name in named for name in ("a", "b", "c")):\n        return named["a"], named["b"], named["c"]\n    numbers = parse_numbers(text)\n    if len(numbers) >= 3:\n        return numbers[0], numbers[1], numbers[2]\n    return None\n\n\ndef extract_expression(text: Text, allow_sqrt: bool = False) -> Optional[Text]:\n    allowed = set("0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ+-*/^().")\n    if allow_sqrt:\n        allowed.add("√")\n    cleaned = "".join(ch if ch in allowed else " " for ch in text)\n    cleaned = cleaned.replace(" ", "")\n    return cleaned or None\n\n\ndef normalize_sqrt_text(text: Text) -> Text:\n    text = text.replace("√", "sqrt")\n    text = re.sub(r"sqrt\\s*(?!\\()([0-9.]+)", r"sqrt(\\1)", text)\n    text = re.sub(r"sqrt\\s*(?!\\()([A-Za-z]+)", r"sqrt(\\1)", text)\n    return text\n\n\ndef parse_sympy_expression(text: Text):\n    normalized = text.replace("^", "**")\n    return parse_expr(normalized, transformations=TRANSFORMATIONS, evaluate=True)\n\n\ndef format_sympy_expr(expr) -> str:\n    return str(expr).replace("**", "^")\n\n\ndef parse_scale_ratio(text: Text) -> Optional[Tuple[float, float]]:\n    match = re.search(r"(\\d+(?:[.,]\\d+)?)\\s*:\\s*(\\d+(?:[.,]\\d+)?)", text)\n    if not match:\n        return None\n    left = float(match.group(1).replace(",", "."))\n    right = float(match.group(2).replace(",", "."))\n    return left, right\n\n\ndef parse_lengths_with_units(text: Text) -> List[Tuple[float, str, float]]:\n    unit_map = {\n        "см": 1.0,\n        "cm": 1.0,\n        "м": 100.0,\n        "метр": 100.0,\n        "км": 100000.0,\n    }\n    results: List[Tuple[float, str, float]] = []\n    for value_str, unit in re.findall(\n        r"(-?\\d+(?:[.,]\\d+)?)\\s*(см|cm|м|метр|км)", text, flags=re.IGNORECASE\n    ):\n        value = float(value_str.replace(",", "."))\n        unit_lower = unit.lower()\n        cm_value = value * unit_map[unit_lower]\n        results.append((value, unit_lower, cm_value))\n    return results\n\n\ndef format_pi_value(coef: float) -> str:\n    coef_text = format_number(coef)\n    if coef_text == "0":\n        return "0"\n    if coef_text == "1":\n        return "pi"\n    return f"{coef_text}*pi"\n\n\nclass ActionSolveQuadratic(Action):\n    def name(self) -> Text:\n        return "action_solve_quadratic"\n\n    def run(\n        self,\n        dispatcher: CollectingDispatcher,\n        tracker: Tracker,\n        domain: Dict[Text, Any],\n    ) -> List[Dict[Text, Any]]:\n        text = tracker.latest_message.get("text", "")\n        coeffs = parse_quadratic_coeffs(text)\n        if coeffs is None:\n            dispatcher.utter_message(\n                text="a, b, c коэффициентээ өгнө үү. Жишээ: квадрат тэгшитгэл бод 1 -3 2"\n            )\n            return []\n        a, b, c = coeffs\n\n        if abs(a) < EPSILON:\n            if abs(b) < EPSILON:\n                if abs(c) < EPSILON:\n                    dispatcher.utter_message(\n                        text="0 = 0 тул хязгааргүй олон шийдтэй."\n                    )\n                else:\n                    dispatcher.utter_message(\n                        text="0x + c = 0 хэлбэр тул шийдгүй."\n                    )\n                return []\n            x = -c / b\n            dispatcher.utter_message(\n                text=f"a=0 тул шугаман тэгшитгэл. x = {format_number(x)}"\n            )\n            return []\n\n        d = b * b - 4 * a * c\n        dispatcher.utter_message(text="Томьёо: x = (-b +/- sqrt(D)) / (2a)")\n        dispatcher.utter_message(text=f"D = b^2 - 4ac = {format_number(d)}")\n\n        if d > EPSILON:\n            sqrt_d = math.sqrt(d)\n            x1 = (-b + sqrt_d) / (2 * a)\n            x2 = (-b - sqrt_d) / (2 * a)\n            dispatcher.utter_message(\n                text=(\n                    "Хоёр бодит шийд: "\n                    f"x1 = {format_number(x1)}, x2 = {format_number(x2)}"\n                )\n            )\n        elif abs(d) <= EPSILON:\n            x = -b / (2 * a)\n            dispatcher.utter_message(text=f"Давхар шийд: x = {format_number(x)}")\n        else:\n            dispatcher.utter_message(text="D < 0 тул бодит шийдгүй.")\n            dispatcher.utter_message(\n                text="Хэрэв комплекс авч үзвэл: x = (-b +/- i*sqrt(|D|)) / (2a)"\n            )\n        return []\n\n\nclass ActionDiscriminant(Action):\n    def name(self) -> Text:\n        return "action_discriminant"\n\n    def run(\n        self,\n        dispatcher: CollectingDispatcher,\n        tracker: Tracker,\n        domain: Dict[Text, Any],\n    ) -> List[Dict[Text, Any]]:\n        text = tracker.latest_message.get("text", "")\n        text_lower = text.lower()\n        coeffs = parse_quadratic_coeffs(text)\n        if coeffs is None:\n            if "томьёо" in text_lower or "гэж юу" in text_lower:\n                dispatcher.utter_message(\n                    text="Дискриминант: D = b^2 - 4ac. D>0 бол 2 бодит шийд, D=0 бол 1 давхар шийд, D<0 бол бодит шийдгүй."\n                )\n                return []\n            dispatcher.utter_message(\n                text="a, b, c-гээ өгнө үү. Жишээ: дискриминант ол 1 -3 2"\n            )\n            return []\n        a, b, c = coeffs\n        d = b * b - 4 * a * c\n        if abs(a) < EPSILON:\n            dispatcher.utter_message(\n                text="a=0 тул квадрат тэгшитгэл биш боловч D = b^2 - 4ac томьёогоор тооцлоо."\n            )\n        dispatcher.utter_message(text=f"D = b^2 - 4ac = {format_number(d)}")\n        if d > EPSILON:\n            dispatcher.utter_message(text="D > 0 тул 2 бодит шийдтэй.")\n        elif abs(d) <= EPSILON:\n            dispatcher.utter_message(text="D = 0 тул 1 давхар шийдтэй.")\n        else:\n            dispatcher.utter_message(text="D < 0 тул бодит шийдгүй.")\n        return []\n\n\nclass ActionFactorOrExpand(Action):\n    def name(self) -> Text:\n        return "action_factor_or_expand"\n\n    def run(\n        self,\n        dispatcher: CollectingDispatcher,\n        tracker: Tracker,\n        domain: Dict[Text, Any],\n    ) -> List[Dict[Text, Any]]:\n        text = tracker.latest_message.get("text", "")\n        text_lower = text.lower()\n        expand_mode = any(word in text_lower for word in ("дэлг", "expand"))\n\n        expr_text = extract_expression(text)\n        if not expr_text:\n            dispatcher.utter_message(\n                text="Илэрхийлэл өгнө үү. Жишээ: x^2-5x+6 -г факторчил, эсвэл (x+3)(x-2) -г дэлгэж өг"\n            )\n            return []\n        try:\n            expr = parse_sympy_expression(expr_text)\n        except Exception:\n            dispatcher.utter_message(text="Илэрхийлэл танигдсангүй. Жишээ: 2x^2+5x+3")\n            return []\n\n        if expand_mode:\n            result = expand(expr)\n            dispatcher.utter_message(\n                text=f"Дэлгэсэн хэлбэр: {format_sympy_expr(result)}"\n            )\n        else:\n            result = factor(expr)\n            dispatcher.utter_message(\n                text=f"Факторчилсон хэлбэр: {format_sympy_expr(result)}"\n            )\n        return []\n\n\nclass ActionSimilarityScale(Action):\n    def name(self) -> Text:\n        return "action_similarity_scale"\n\n    def run(\n        self,\n        dispatcher: CollectingDispatcher,\n        tracker: Tracker,\n        domain: Dict[Text, Any],\n    ) -> List[Dict[Text, Any]]:\n        text = tracker.latest_message.get("text", "")\n        text_lower = text.lower()\n\n        if "периметр" in text_lower and ("харьцаа" in text_lower or "харьцаатай" in text_lower):\n            numbers = parse_numbers(text_lower)\n            if len(numbers) >= 2:\n                a, b = numbers[-2], numbers[-1]\n                dispatcher.utter_message(\n                    text=f"Периметрүүдийн харьцаа талуудын адил: {format_number(a)}:{format_number(b)}"\n                )\n                return []\n\n        if "талбай" in text_lower and "масштаб" in text_lower:\n            numbers = parse_numbers(text_lower)\n            if numbers:\n                area_factor = numbers[0]\n                scale = math.sqrt(area_factor)\n                dispatcher.utter_message(\n                    text=f"Талбай k^2-оор өснө. k = sqrt({format_number(area_factor)}) = {format_number(scale)}"\n                )\n                return []\n\n        if "урт" in text_lower and "эзэлхүүн" in text_lower:\n            numbers = parse_numbers(text_lower)\n            if numbers:\n                length_factor = numbers[0]\n                volume_factor = length_factor ** 3\n                dispatcher.utter_message(\n                    text=f"Эзэлхүүн k^3-оор өөрчлөгдөнө: {format_number(volume_factor)} дахин."\n                )\n                return []\n\n        if "томруул" in text_lower and "масштаб" in text_lower:\n            numbers = parse_numbers(text_lower)\n            if numbers:\n                factor = numbers[0]\n                dispatcher.utter_message(\n                    text=f"Масштаб = {format_number(factor)}:1 (эсвэл 1:{format_number(1 / factor)})"\n                )\n                return []\n\n        if "масштаб" in text_lower and ("ол" in text_lower or "хэд" in text_lower) and "1:" not in text_lower:\n            lengths = parse_lengths_with_units(text_lower)\n            if len(lengths) >= 2:\n                map_cm = lengths[0][2]\n                real_cm = lengths[1][2]\n                if map_cm > EPSILON:\n                    scale = real_cm / map_cm\n                    dispatcher.utter_message(\n                        text=f"Масштаб = 1:{format_number(scale)}"\n                    )\n                    return []\n\n        ratio = parse_scale_ratio(text_lower)\n        lengths = parse_lengths_with_units(text_lower)\n        if ratio and lengths:\n            left, right = ratio\n            if abs(left) < EPSILON:\n                dispatcher.utter_message(text="Масштабын зүүн тал 0 байж болохгүй.")\n                return []\n            map_cm = lengths[0][2]\n            real_cm = map_cm * (right / left)\n            if "км" in text_lower:\n                km = real_cm / 100000.0\n                dispatcher.utter_message(text=f"Бодит зай: {format_number(km)} км")\n                return []\n            if "метр" in text_lower:\n                meters = real_cm / 100.0\n                dispatcher.utter_message(text=f"Бодит зай: {format_number(meters)} м")\n                return []\n            dispatcher.utter_message(\n                text=f"Бодит зай: {format_number(real_cm)} см = {format_number(real_cm / 100.0)} м"\n            )\n            return []\n\n        if "масштаб" in text_lower:\n            match_ab = re.search(r"ab\\s*=\\s*(-?\\d+(?:[.,]\\d+)?)", text_lower)\n            match_apb = re.search(\n                r"a[\'’]b[\'’]\\s*=\\s*(-?\\d+(?:[.,]\\d+)?)", text_lower\n            )\n            if match_ab and match_apb:\n                ab = float(match_ab.group(1).replace(",", "."))\n                apb = float(match_apb.group(1).replace(",", "."))\n                if abs(ab) > EPSILON:\n                    scale = apb / ab\n                    dispatcher.utter_message(\n                        text=f"Масштаб k = {format_number(scale)}"\n                    )\n                    return []\n\n        dispatcher.utter_message(\n            text="Төсөө/масштаб: уртын харьцаа k, талбай k^2, эзэлхүүн k^3. Жишээ: масштаб 1:500 дээр 4см нь бодит хэд вэ?"\n        )\n        return []\n\n\nclass ActionProbability(Action):\n    def name(self) -> Text:\n        return "action_probability"\n\n    def run(\n        self,\n        dispatcher: CollectingDispatcher,\n        tracker: Tracker,\n        domain: Dict[Text, Any],\n    ) -> List[Dict[Text, Any]]:\n        text = tracker.latest_message.get("text", "")\n        text_lower = text.lower()\n\n        if "шоо" in text_lower:\n            two_times = ("2" in text_lower or "хоёр" in text_lower) and "удаа" in text_lower\n            if two_times and "6" in text_lower:\n                dispatcher.utter_message(text=f"P = {format_fraction(1, 36)}")\n                return []\n            if "6" in text_lower:\n                dispatcher.utter_message(text=f"P = {format_fraction(1, 6)}")\n                return []\n\n        if "зос" in text_lower and ("3" in text_lower or "гурав" in text_lower):\n            if ("2" in text_lower or "хоёр" in text_lower) and "сүлд" in text_lower:\n                dispatcher.utter_message(text=f"P = {format_fraction(3, 8)}")\n                return []\n\n        if "улаан" in text_lower and "цэнхэр" in text_lower:\n            red_match = re.search(r"(\\d+)\\s*улаан", text_lower)\n            blue_match = re.search(r"(\\d+)\\s*цэнхэр", text_lower)\n            red = int(red_match.group(1)) if red_match else 3\n            blue = int(blue_match.group(1)) if blue_match else 2\n            total = red + blue\n            if "буцаахгүй" in text_lower and "цэнхэр" in text_lower:\n                dispatcher.utter_message(\n                    text=f"P = {format_fraction(blue, total)} (өөрчлөхгүй гэж үзэв)"\n                )\n                return []\n            if "улаан" in text_lower and "магадлал" in text_lower and "цэнхэр гарах" not in text_lower:\n                dispatcher.utter_message(text=f"P = {format_fraction(red, total)}")\n                return []\n            if "цэнхэр" in text_lower and "магадлал" in text_lower:\n                dispatcher.utter_message(text=f"P = {format_fraction(blue, total)}")\n                return []\n\n        dispatcher.utter_message(\n            text="Магадлал: P(A)=таатай/нийт. Жишээ: шоо нэг шидэхэд 6 буух магадлал хэд вэ?"\n        )\n        return []\n\n\nclass ActionStatistics(Action):\n    def name(self) -> Text:\n        return "action_statistics"\n\n    def run(\n        self,\n        dispatcher: CollectingDispatcher,\n        tracker: Tracker,\n        domain: Dict[Text, Any],\n    ) -> List[Dict[Text, Any]]:\n        text = tracker.latest_message.get("text", "")\n        text_lower = text.lower()\n        numbers = parse_numbers(text)\n        if not numbers:\n            if "суурь" in text_lower or "үндэс" in text_lower:\n                dispatcher.utter_message(\n                    text="Статистик: дундаж, медиан, мод, хүрээ, дисперс зэрэг үзүүлэлтүүдтэй."\n                )\n                return []\n            dispatcher.utter_message(\n                text="Өгөгдлөө өгнө үү. Жишээ: дундаж ол 2 4 6 8 10"\n            )\n            return []\n\n        if "дундаж" in text_lower:\n            mean = sum(numbers) / len(numbers)\n            dispatcher.utter_message(text=f"Дундаж = {format_number(mean)}")\n            return []\n\n        if "медиан" in text_lower:\n            nums = sorted(numbers)\n            n = len(nums)\n            if n % 2 == 1:\n                median = nums[n // 2]\n            else:\n                median = (nums[n // 2 - 1] + nums[n // 2]) / 2\n            dispatcher.utter_message(text=f"Медиан = {format_number(median)}")\n            return []\n\n        if "мод" in text_lower:\n            freq: Dict[float, int] = {}\n            for num in numbers:\n                freq[num] = freq.get(num, 0) + 1\n            max_count = max(freq.values())\n            modes = [num for num, count in freq.items() if count == max_count]\n            mode_text = ", ".join(format_number(num) for num in sorted(modes))\n            dispatcher.utter_message(text=f"Мод = {mode_text}")\n            return []\n\n        if "хүрээ" in text_lower or "range" in text_lower:\n            data_range = max(numbers) - min(numbers)\n            dispatcher.utter_message(text=f"Хүрээ = {format_number(data_range)}")\n            return []\n\n        if "дисперс" in text_lower:\n            mean = sum(numbers) / len(numbers)\n            variance = sum((x - mean) ** 2 for x in numbers) / len(numbers)\n            dispatcher.utter_message(\n                text=f"Дисперс (суурь, n-т хуваасан) = {format_number(variance)}"\n            )\n            return []\n\n        dispatcher.utter_message(\n            text="Статистикийн төрөл танигдсангүй (дундаж/медиан/мод/хүрээ/дисперс)."\n        )\n        return []\n\n\nclass ActionTrigonometry(Action):\n    def name(self) -> Text:\n        return "action_trigonometry"\n\n    def run(\n        self,\n        dispatcher: CollectingDispatcher,\n        tracker: Tracker,\n        domain: Dict[Text, Any],\n    ) -> List[Dict[Text, Any]]:\n        text = tracker.latest_message.get("text", "")\n        text_lower = text.lower()\n\n        if "sin^2" in text_lower and "cos^2" in text_lower:\n            dispatcher.utter_message(\n                text="sin^2(x) + cos^2(x) = 1 нь нэгж тойргийн үндсэн адилтгал."\n            )\n            return []\n\n        if "радиан" in text_lower and "градус" in text_lower:\n            if "pi" in text_lower or "π" in text:\n                match = re.search(r"(\\d+)?\\s*(pi|π)\\s*/\\s*(\\d+)", text_lower)\n                if match:\n                    numerator = int(match.group(1) or "1")\n                    denominator = int(match.group(3))\n                    degrees = 180 * numerator / denominator\n                    if numerator == 1:\n                        rad_text = f"pi/{denominator}"\n                    else:\n                        rad_text = f"{numerator}*pi/{denominator}"\n                    dispatcher.utter_message(\n                        text=f"{rad_text} радиан = {format_number(degrees)} градус"\n                    )\n                    return []\n            match = re.search(r"(-?\\d+(?:[.,]\\d+)?)\\s*градус", text_lower)\n            if match:\n                deg = float(match.group(1).replace(",", "."))\n                exact = {\n                    30: "pi/6",\n                    45: "pi/4",\n                    60: "pi/3",\n                    90: "pi/2",\n                    180: "pi",\n                    135: "3*pi/4",\n                    150: "5*pi/6",\n                }\n                if deg in exact:\n                    dispatcher.utter_message(\n                        text=f"{format_number(deg)} градус = {exact[deg]} радиан"\n                    )\n                else:\n                    rad = deg * math.pi / 180\n                    dispatcher.utter_message(\n                        text=f"{format_number(deg)} градус = {format_number(rad)} радиан"\n                    )\n                return []\n\n        sin_values = {0: "0", 30: "1/2", 90: "1", 150: "1/2"}\n        cos_values = {0: "1", 60: "1/2", 180: "-1"}\n        tan_values = {45: "1", 135: "-1"}\n\n        if "sin" in text_lower:\n            angles = [int(a) for a in re.findall(r"sin\\s*\\(?\\s*(\\d+)", text_lower)]\n            if "pi/6" in text_lower or "π/6" in text:\n                dispatcher.utter_message(text="sin(pi/6) = 1/2")\n                return []\n            if angles:\n                parts = []\n                for angle in angles:\n                    value = sin_values.get(angle)\n                    if value is None:\n                        value = format_number(math.sin(math.radians(angle)))\n                    parts.append(f"sin {angle} = {value}")\n                dispatcher.utter_message(text=", ".join(parts))\n                return []\n\n        if "cos" in text_lower:\n            angles = [int(a) for a in re.findall(r"cos\\s*\\(?\\s*(\\d+)", text_lower)]\n            if "pi/3" in text_lower or "π/3" in text:\n                dispatcher.utter_message(text="cos(pi/3) = 1/2")\n                return []\n            if angles:\n                parts = []\n                for angle in angles:\n                    value = cos_values.get(angle)\n                    if value is None:\n                        value = format_number(math.cos(math.radians(angle)))\n                    parts.append(f"cos {angle} = {value}")\n                dispatcher.utter_message(text=", ".join(parts))\n                return []\n\n        if "tan" in text_lower:\n            angles = [int(a) for a in re.findall(r"tan\\s*\\(?\\s*(\\d+)", text_lower)]\n            if angles:\n                parts = []\n                for angle in angles:\n                    if angle == 90:\n                        value = "тодорхойгүй"\n                    else:\n                        value = tan_values.get(angle)\n                        if value is None:\n                            value = format_number(math.tan(math.radians(angle)))\n                    parts.append(f"tan {angle} = {value}")\n                dispatcher.utter_message(text=", ".join(parts))\n                return []\n\n        dispatcher.utter_message(\n            text="Суурь томьёо: sin=эсрэг/гипотенуз, cos=залгаа/гипотенуз, tan=эсрэг/залгаа. Жишээ: sin 30, cos 60, tan 45."\n        )\n        return []\n\n\nclass ActionSquareRoots(Action):\n    def name(self) -> Text:\n        return "action_square_roots"\n\n    def run(\n        self,\n        dispatcher: CollectingDispatcher,\n        tracker: Tracker,\n        domain: Dict[Text, Any],\n    ) -> List[Dict[Text, Any]]:\n        text = tracker.latest_message.get("text", "")\n        text_lower = text.lower()\n\n        expr_text = extract_expression(text, allow_sqrt=True)\n        if not expr_text:\n            dispatcher.utter_message(\n                text="Квадрат язгуур: a^2 = a*a, sqrt(a^2)=|a|. Жишээ: √50, √72, 1/√5"\n            )\n            return []\n        expr_text = normalize_sqrt_text(expr_text)\n\n        try:\n            expr = parse_sympy_expression(expr_text)\n        except Exception:\n            dispatcher.utter_message(text="Язгуурын илэрхийлэл танигдсангүй.")\n            return []\n\n        if "язгуургүй" in text_lower or "rationalize" in text_lower:\n            result = radsimp(expr)\n            dispatcher.utter_message(text=f"Хариу: {format_sympy_expr(result)}")\n            return []\n\n        result = simplify(expr)\n        if result.has(I):\n            dispatcher.utter_message(\n                text="Бодит тоонд боломжгүй. Комплекс тоонд: "\n                f"{format_sympy_expr(result)}"\n            )\n            return []\n        dispatcher.utter_message(text=f"Хариу: {format_sympy_expr(result)}")\n        return []\n\n\nclass ActionCone(Action):\n    def name(self) -> Text:\n        return "action_cone"\n\n    def run(\n        self,\n        dispatcher: CollectingDispatcher,\n        tracker: Tracker,\n        domain: Dict[Text, Any],\n    ) -> List[Dict[Text, Any]]:\n        text = tracker.latest_message.get("text", "")\n        text_lower = text.lower()\n\n        def extract_value(patterns: List[str]) -> Optional[float]:\n            for pattern in patterns:\n                match = re.search(pattern, text_lower)\n                if match:\n                    return float(match.group(1).replace(",", "."))\n            return None\n\n        r_value = extract_value([r"\\br\\s*[:=]\\s*(-?\\d+(?:[.,]\\d+)?)", r"радиус\\s*(-?\\d+(?:[.,]\\d+)?)"])\n        h_value = extract_value([r"\\bh\\s*[:=]\\s*(-?\\d+(?:[.,]\\d+)?)", r"өндөр\\s*(-?\\d+(?:[.,]\\d+)?)"])\n        l_value = extract_value([r"\\bl\\s*[:=]\\s*(-?\\d+(?:[.,]\\d+)?)", r"ташуу\\s*[-\\w]*\\s*(-?\\d+(?:[.,]\\d+)?)"])\n        d_value = extract_value([r"диаметр\\s*(-?\\d+(?:[.,]\\d+)?)", r"\\bd\\s*[:=]\\s*(-?\\d+(?:[.,]\\d+)?)"])\n\n        if "бөмбөрцөг" in text_lower and "конус" in text_lower and not any(\n            word in text_lower for word in ("r=", "h=", "l=", "диаметр")\n        ):\n            dispatcher.utter_message(\n                text=(\n                    "Конус: V = (1/3)*pi*r^2*h, l = sqrt(r^2 + h^2), "\n                    "Sx = pi*r*l, S = pi*r^2 + pi*r*l. "\n                    "Бөмбөрцөг: S = 4*pi*r^2, V = (4/3)*pi*r^3."\n                )\n            )\n            return []\n\n        if "байгуулагч" in text_lower or "ташуу" in text_lower:\n            if r_value is not None and h_value is not None:\n                l_calc = math.sqrt(r_value ** 2 + h_value ** 2)\n                dispatcher.utter_message(\n                    text=f"l = sqrt(r^2 + h^2) = {format_number(l_calc)}"\n                )\n                return []\n            dispatcher.utter_message(\n                text="l = sqrt(r^2 + h^2) томьёогоор олно. r, h-ийг өгнө үү."\n            )\n            return []\n\n        if "хажуу" in text_lower:\n            if r_value is not None and l_value is not None:\n                coef = r_value * l_value\n                dispatcher.utter_message(\n                    text=f"Sx = pi*r*l = {format_pi_value(coef)} (~{format_number(coef * math.pi)})"\n                )\n                return []\n            dispatcher.utter_message(\n                text="Хажуу гадаргуу: Sx = pi*r*l. r, l-ийг өгнө үү."\n            )\n            return []\n\n        if "нийт" in text_lower:\n            if r_value is not None and l_value is not None:\n                coef = r_value ** 2 + r_value * l_value\n                dispatcher.utter_message(\n                    text=f"S = pi*(r^2 + r*l) = {format_pi_value(coef)} (~{format_number(coef * math.pi)})"\n                )\n                return []\n            dispatcher.utter_message(\n                text="Нийт гадаргуу: S = pi*r^2 + pi*r*l. r, l-ийг өгнө үү."\n            )\n            return []\n\n        if "эзэлхүүн" in text_lower or "v" in text_lower:\n            if r_value is None and d_value is not None:\n                r_value = d_value / 2\n            if r_value is not None and h_value is not None:\n                coef = (r_value ** 2 * h_value) / 3\n                dispatcher.utter_message(\n                    text=f"V = (1/3)*pi*r^2*h = {format_pi_value(coef)} (~{format_number(coef * math.pi)})"\n                )\n                return []\n            dispatcher.utter_message(\n                text="Эзэлхүүн: V = (1/3)*pi*r^2*h. r, h (эсвэл диаметр, өндөр)-ийг өгнө үү."\n            )\n            return []\n\n        dispatcher.utter_message(\n            text="Конусын томьёо: V=(1/3)*pi*r^2*h, l=sqrt(r^2+h^2), Sx=pi*r*l, S=pi*r^2+pi*r*l."\n        )\n        return []\n\n\nclass ActionSphere(Action):\n    def name(self) -> Text:\n        return "action_sphere"\n\n    def run(\n        self,\n        dispatcher: CollectingDispatcher,\n        tracker: Tracker,\n        domain: Dict[Text, Any],\n    ) -> List[Dict[Text, Any]]:\n        text = tracker.latest_message.get("text", "")\n        text_lower = text.lower()\n\n        def extract_value(patterns: List[str]) -> Optional[float]:\n            for pattern in patterns:\n                match = re.search(pattern, text_lower)\n                if match:\n                    return float(match.group(1).replace(",", "."))\n            return None\n\n        r_value = extract_value([r"\\br\\s*[:=]\\s*(-?\\d+(?:[.,]\\d+)?)", r"радиус\\s*(-?\\d+(?:[.,]\\d+)?)"])\n        d_value = extract_value([r"диаметр\\s*(-?\\d+(?:[.,]\\d+)?)", r"\\bd\\s*[:=]\\s*(-?\\d+(?:[.,]\\d+)?)"])\n\n        v_match = re.search(r"v\\s*=\\s*(-?\\d+(?:[.,]\\d+)?)\\s*(pi|π)", text_lower)\n        if v_match and ("r ол" in text_lower or "радиус" in text_lower):\n            coef = float(v_match.group(1).replace(",", "."))\n            r_calc = (3 * coef / 4) ** (1 / 3)\n            dispatcher.utter_message(\n                text=f"V = (4/3)*pi*r^3 => r = {format_number(r_calc)}"\n            )\n            return []\n\n        if r_value is None and d_value is not None:\n            r_value = d_value / 2\n\n        if "эзэлхүүн" in text_lower or "v" in text_lower:\n            if r_value is not None:\n                coef = (4 * r_value ** 3) / 3\n                dispatcher.utter_message(\n                    text=f"V = (4/3)*pi*r^3 = {format_pi_value(coef)} (~{format_number(coef * math.pi)})"\n                )\n                return []\n            dispatcher.utter_message(\n                text="Эзэлхүүн: V = (4/3)*pi*r^3. r (эсвэл диаметр)-ийг өгнө үү."\n            )\n            return []\n\n        if "гадаргуу" in text_lower:\n            if r_value is not None:\n                coef = 4 * r_value ** 2\n                dispatcher.utter_message(\n                    text=f"S = 4*pi*r^2 = {format_pi_value(coef)} (~{format_number(coef * math.pi)})"\n                )\n                return []\n            dispatcher.utter_message(text="Гадаргуу: S = 4*pi*r^2. r-ийг өгнө үү.")\n            return []\n\n        dispatcher.utter_message(\n            text="Бөмбөрцөг: S = 4*pi*r^2, V = (4/3)*pi*r^3."\n        )\n        return []\n'
_mod_4 = _load_module('_actions_part_4_grade_7_9_part1_actions', _SRC_4)
_SRC_5 = 'from typing import Any, Dict, List, Text, Optional\nimport math\nimport re\n\nfrom rasa_sdk import Action, Tracker\nfrom rasa_sdk.executor import CollectingDispatcher\nfrom rasa_sdk.forms import FormValidationAction\nfrom rasa_sdk.events import AllSlotsReset\n\nNUMBER_MESSAGE = "Please enter a number. (e.g., 2, -3, 4.5)"\nPOSITIVE_MESSAGE = "Please enter a positive number. (e.g., 2, 4.5)"\n\n\ndef _parse_number(text: str) -> Optional[float]:\n    if not text:\n        return None\n    t = text.strip().replace(",", ".")\n    m = re.search(r"-?\\d+(?:\\.\\d+)?", t)\n    if not m:\n        return None\n    try:\n        return float(m.group(0))\n    except Exception:\n        return None\n\n\ndef _fmt_num(value: float) -> str:\n    return f"{value:g}"\n\n\nclass ValidateMath8Form(FormValidationAction):\n    def name(self) -> Text:\n        return "validate_math8_form"\n\n    async def required_slots(\n        self,\n        slots_mapped_in_domain: List[Text],\n        dispatcher: CollectingDispatcher,\n        tracker: Tracker,\n        domain: Dict[Text, Any],\n    ) -> List[Text]:\n        topic = tracker.get_slot("topic")\n\n        if not topic:\n            return ["topic"]\n\n        if topic == "identity":\n            return ["topic", "identity_type", "id_a", "id_b"]\n\n        if topic == "quadratic":\n            return ["topic", "quad_a", "quad_b", "quad_c"]\n\n        if topic == "system":\n            return ["topic", "sys_a1", "sys_b1", "sys_c1", "sys_a2", "sys_b2", "sys_c2"]\n\n        if topic == "circle":\n            return ["topic", "circle_r"]\n\n        if topic == "trig":\n            return ["topic", "trig_opp", "trig_adj", "trig_hyp"]\n\n        return ["topic"]\n\n    def validate_topic(self, value: Text, dispatcher, tracker, domain) -> Dict[Text, Any]:\n        if not value:\n            dispatcher.utter_message(text="Please choose a topic.")\n            return {"topic": None}\n\n        v = value.strip().lower()\n        mapping = {\n            "identity": "identity",\n            "quadratic": "quadratic",\n            "system": "system",\n            "circle": "circle",\n            "trig": "trig",\n            "square identity": "identity",\n            "quadratic equation": "quadratic",\n            "linear system": "system",\n            "circle formula": "circle",\n            "trigonometry": "trig",\n            "??????? ??????????": "identity",\n            "??????? ?????????": "quadratic",\n            "??????": "system",\n            "??????": "circle",\n            "???????????": "trig",\n        }\n\n        topic = mapping.get(v, v)\n        allowed = {"identity", "quadratic", "system", "circle", "trig"}\n        if topic not in allowed:\n            dispatcher.utter_message(text="Unknown topic. Choose again.")\n            return {"topic": None}\n\n        return {\n            "topic": topic,\n            "identity_type": None,\n            "id_a": None,\n            "id_b": None,\n            "quad_a": None,\n            "quad_b": None,\n            "quad_c": None,\n            "sys_a1": None,\n            "sys_b1": None,\n            "sys_c1": None,\n            "sys_a2": None,\n            "sys_b2": None,\n            "sys_c2": None,\n            "circle_r": None,\n            "trig_opp": None,\n            "trig_adj": None,\n            "trig_hyp": None,\n        }\n\n    def validate_identity_type(self, value: Text, dispatcher, tracker, domain) -> Dict[Text, Any]:\n        if not value:\n            dispatcher.utter_message(text="Choose an identity type.")\n            return {"identity_type": None}\n\n        v = value.strip().lower().replace(" ", "")\n        mapping = {\n            "(a+b)^2": "square_sum",\n            "(a-b)^2": "square_diff",\n            "a^2-b^2": "diff_squares",\n            "square_sum": "square_sum",\n            "square_diff": "square_diff",\n            "diff_squares": "diff_squares",\n            "squareofsum": "square_sum",\n            "squareofdiff": "square_diff",\n            "differenceofsquares": "diff_squares",\n        }\n\n        identity_type = mapping.get(v, v)\n        if identity_type not in {"square_sum", "square_diff", "diff_squares"}:\n            dispatcher.utter_message(text="Unknown identity type.")\n            return {"identity_type": None}\n\n        return {"identity_type": identity_type}\n\n    def _validate_number(self, slot_name: Text, dispatcher: CollectingDispatcher, value: Any) -> Dict[Text, Any]:\n        num = _parse_number(str(value))\n        if num is None:\n            dispatcher.utter_message(text=NUMBER_MESSAGE)\n            return {slot_name: None}\n        return {slot_name: float(num)}\n\n    def _validate_positive(self, slot_name: Text, dispatcher: CollectingDispatcher, value: Any) -> Dict[Text, Any]:\n        num = _parse_number(str(value))\n        if num is None or num <= 0:\n            dispatcher.utter_message(text=POSITIVE_MESSAGE)\n            return {slot_name: None}\n        return {slot_name: float(num)}\n\n    def validate_id_a(self, value: Any, dispatcher, tracker, domain):\n        return self._validate_number("id_a", dispatcher, value)\n\n    def validate_id_b(self, value: Any, dispatcher, tracker, domain):\n        return self._validate_number("id_b", dispatcher, value)\n\n    def validate_quad_a(self, value: Any, dispatcher, tracker, domain):\n        return self._validate_number("quad_a", dispatcher, value)\n\n    def validate_quad_b(self, value: Any, dispatcher, tracker, domain):\n        return self._validate_number("quad_b", dispatcher, value)\n\n    def validate_quad_c(self, value: Any, dispatcher, tracker, domain):\n        return self._validate_number("quad_c", dispatcher, value)\n\n    def validate_sys_a1(self, value: Any, dispatcher, tracker, domain):\n        return self._validate_number("sys_a1", dispatcher, value)\n\n    def validate_sys_b1(self, value: Any, dispatcher, tracker, domain):\n        return self._validate_number("sys_b1", dispatcher, value)\n\n    def validate_sys_c1(self, value: Any, dispatcher, tracker, domain):\n        return self._validate_number("sys_c1", dispatcher, value)\n\n    def validate_sys_a2(self, value: Any, dispatcher, tracker, domain):\n        return self._validate_number("sys_a2", dispatcher, value)\n\n    def validate_sys_b2(self, value: Any, dispatcher, tracker, domain):\n        return self._validate_number("sys_b2", dispatcher, value)\n\n    def validate_sys_c2(self, value: Any, dispatcher, tracker, domain):\n        return self._validate_number("sys_c2", dispatcher, value)\n\n    def validate_circle_r(self, value: Any, dispatcher, tracker, domain):\n        return self._validate_positive("circle_r", dispatcher, value)\n\n    def validate_trig_opp(self, value: Any, dispatcher, tracker, domain):\n        return self._validate_positive("trig_opp", dispatcher, value)\n\n    def validate_trig_adj(self, value: Any, dispatcher, tracker, domain):\n        return self._validate_positive("trig_adj", dispatcher, value)\n\n    def validate_trig_hyp(self, value: Any, dispatcher, tracker, domain):\n        return self._validate_positive("trig_hyp", dispatcher, value)\n\n\nclass ActionCalculateMath8(Action):\n    def name(self) -> Text:\n        return "action_calculate_math8"\n\n    def run(self, dispatcher: CollectingDispatcher, tracker: Tracker, domain: Dict[Text, Any]) -> List[Dict[Text, Any]]:\n        topic = tracker.get_slot("topic")\n\n        if topic == "identity":\n            identity_type = tracker.get_slot("identity_type")\n            a = tracker.get_slot("id_a")\n            b = tracker.get_slot("id_b")\n            if a is None or b is None:\n                dispatcher.utter_message(text=NUMBER_MESSAGE)\n                return []\n            a = float(a)\n            b = float(b)\n\n            if identity_type == "square_sum":\n                value = (a + b) ** 2\n                dispatcher.utter_message(\n                    text=(\n                        "(a + b)^2 = a^2 + 2ab + b^2. "\n                        f"For a={_fmt_num(a)}, b={_fmt_num(b)}: (a+b)^2 = {_fmt_num(value)}"\n                    )\n                )\n                return []\n\n            if identity_type == "square_diff":\n                value = (a - b) ** 2\n                dispatcher.utter_message(\n                    text=(\n                        "(a - b)^2 = a^2 - 2ab + b^2. "\n                        f"For a={_fmt_num(a)}, b={_fmt_num(b)}: (a-b)^2 = {_fmt_num(value)}"\n                    )\n                )\n                return []\n\n            if identity_type == "diff_squares":\n                value = a ** 2 - b ** 2\n                dispatcher.utter_message(\n                    text=(\n                        "a^2 - b^2 = (a-b)(a+b). "\n                        f"For a={_fmt_num(a)}, b={_fmt_num(b)}: a^2-b^2 = {_fmt_num(value)}"\n                    )\n                )\n                return []\n\n            dispatcher.utter_message(text="Unknown identity type.")\n            return []\n\n        if topic == "quadratic":\n            a = tracker.get_slot("quad_a")\n            b = tracker.get_slot("quad_b")\n            c = tracker.get_slot("quad_c")\n            if a is None or b is None or c is None:\n                dispatcher.utter_message(text=NUMBER_MESSAGE)\n                return []\n            a = float(a)\n            b = float(b)\n            c = float(c)\n\n            if abs(a) < 1e-9:\n                if abs(b) < 1e-9:\n                    dispatcher.utter_message(text="Not a valid equation (a=0 and b=0).")\n                    return []\n                x = -c / b\n                dispatcher.utter_message(text=f"Linear equation: x = {_fmt_num(x)}")\n                return []\n\n            d = b * b - 4 * a * c\n            if d > 0:\n                sqrt_d = math.sqrt(d)\n                x1 = (-b - sqrt_d) / (2 * a)\n                x2 = (-b + sqrt_d) / (2 * a)\n                dispatcher.utter_message(\n                    text=(\n                        f"D = {_fmt_num(d)}. Two real roots: x1 = {_fmt_num(x1)}, x2 = {_fmt_num(x2)}"\n                    )\n                )\n                return []\n            if abs(d) < 1e-9:\n                x = -b / (2 * a)\n                dispatcher.utter_message(text=f"D = 0. One real root: x = {_fmt_num(x)}")\n                return []\n\n            dispatcher.utter_message(text=f"D = {_fmt_num(d)} < 0. No real roots.")\n            return []\n\n        if topic == "system":\n            a1 = tracker.get_slot("sys_a1")\n            b1 = tracker.get_slot("sys_b1")\n            c1 = tracker.get_slot("sys_c1")\n            a2 = tracker.get_slot("sys_a2")\n            b2 = tracker.get_slot("sys_b2")\n            c2 = tracker.get_slot("sys_c2")\n            if None in (a1, b1, c1, a2, b2, c2):\n                dispatcher.utter_message(text=NUMBER_MESSAGE)\n                return []\n            a1 = float(a1)\n            b1 = float(b1)\n            c1 = float(c1)\n            a2 = float(a2)\n            b2 = float(b2)\n            c2 = float(c2)\n\n            det = a1 * b2 - a2 * b1\n            if abs(det) < 1e-9:\n                dispatcher.utter_message(text="No unique solution (determinant is 0).")\n                return []\n\n            x = (c1 * b2 - c2 * b1) / det\n            y = (a1 * c2 - a2 * c1) / det\n            dispatcher.utter_message(\n                text=f"Solution: x = {_fmt_num(x)}, y = {_fmt_num(y)}"\n            )\n            return []\n\n        if topic == "circle":\n            r = tracker.get_slot("circle_r")\n            if r is None:\n                dispatcher.utter_message(text=POSITIVE_MESSAGE)\n                return []\n            r = float(r)\n            c = 2 * math.pi * r\n            s = math.pi * r * r\n            dispatcher.utter_message(\n                text=(\n                    f"C = 2*pi*r = {_fmt_num(c)}; S = pi*r^2 = {_fmt_num(s)}"\n                )\n            )\n            return []\n\n        if topic == "trig":\n            opp = tracker.get_slot("trig_opp")\n            adj = tracker.get_slot("trig_adj")\n            hyp = tracker.get_slot("trig_hyp")\n            if None in (opp, adj, hyp):\n                dispatcher.utter_message(text=POSITIVE_MESSAGE)\n                return []\n            opp = float(opp)\n            adj = float(adj)\n            hyp = float(hyp)\n\n            if abs(hyp) < 1e-9 or abs(adj) < 1e-9:\n                dispatcher.utter_message(text="Invalid sides for trig ratios.")\n                return []\n\n            sin_v = opp / hyp\n            cos_v = adj / hyp\n            tan_v = None if abs(adj) < 1e-9 else opp / adj\n\n            if tan_v is None:\n                dispatcher.utter_message(\n                    text=(\n                        f"sin = {_fmt_num(sin_v)}, cos = {_fmt_num(cos_v)}, tan is undefined"\n                    )\n                )\n                return []\n\n            dispatcher.utter_message(\n                text=(\n                    f"sin = {_fmt_num(sin_v)}, cos = {_fmt_num(cos_v)}, tan = {_fmt_num(tan_v)}"\n                )\n            )\n            return []\n\n        dispatcher.utter_message(text="Unknown topic.")\n        return []\n\n\nclass ActionResetMath8(Action):\n    def name(self) -> Text:\n        return "action_reset_math8"\n\n    def run(self, dispatcher: CollectingDispatcher, tracker: Tracker, domain: Dict[Text, Any]) -> List[Dict[Text, Any]]:\n        return [AllSlotsReset()]\n'
_mod_5 = _load_module('_actions_part_5_grade_7_9_part2_actions', _SRC_5)
_SRC_6 = 'from __future__ import annotations\n\nimport math\nimport re\nfrom typing import Any, Dict, List, Optional, Text, Tuple\n\nfrom rasa_sdk import Action, Tracker\nfrom rasa_sdk.executor import CollectingDispatcher\nfrom sympy import I, factor, expand, simplify\nfrom sympy.parsing.sympy_parser import (\n    convert_xor,\n    implicit_multiplication_application,\n    parse_expr,\n    standard_transformations,\n)\nfrom sympy.simplify.radsimp import radsimp\n\nEPSILON = 1e-9\nNUMBER_RE = re.compile(r"-?\\d+(?:[.,]\\d+)?")\nTRANSFORMATIONS = standard_transformations + (\n    implicit_multiplication_application,\n    convert_xor,\n)\n\n\ndef parse_numbers(text: Text) -> List[float]:\n    return [float(n.replace(",", ".")) for n in NUMBER_RE.findall(text)]\n\n\ndef format_number(value: float) -> str:\n    if abs(value - round(value)) < EPSILON:\n        return str(int(round(value)))\n    return f"{value:.4f}".rstrip("0").rstrip(".")\n\n\ndef format_fraction(numerator: int, denominator: int) -> str:\n    gcd_value = math.gcd(numerator, denominator)\n    numerator //= gcd_value\n    denominator //= gcd_value\n    return f"{numerator}/{denominator} (~{numerator / denominator:.4f})"\n\n\ndef parse_named_coefficients(text: Text) -> Dict[Text, float]:\n    coeffs: Dict[Text, float] = {}\n    for name in ("a", "b", "c"):\n        match = re.search(\n            rf"\\b{name}\\s*[:=]\\s*(-?\\d+(?:[.,]\\d+)?)",\n            text,\n            flags=re.IGNORECASE,\n        )\n        if match:\n            coeffs[name] = float(match.group(1).replace(",", "."))\n    return coeffs\n\n\ndef parse_quadratic_coeffs(text: Text) -> Optional[Tuple[float, float, float]]:\n    named = parse_named_coefficients(text)\n    if all(name in named for name in ("a", "b", "c")):\n        return named["a"], named["b"], named["c"]\n    numbers = parse_numbers(text)\n    if len(numbers) >= 3:\n        return numbers[0], numbers[1], numbers[2]\n    return None\n\n\ndef extract_expression(text: Text, allow_sqrt: bool = False) -> Optional[Text]:\n    allowed = set("0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ+-*/^().")\n    if allow_sqrt:\n        allowed.add("√")\n    cleaned = "".join(ch if ch in allowed else " " for ch in text)\n    cleaned = cleaned.replace(" ", "")\n    return cleaned or None\n\n\ndef normalize_sqrt_text(text: Text) -> Text:\n    text = text.replace("√", "sqrt")\n    text = re.sub(r"sqrt\\s*(?!\\()([0-9.]+)", r"sqrt(\\1)", text)\n    text = re.sub(r"sqrt\\s*(?!\\()([A-Za-z]+)", r"sqrt(\\1)", text)\n    return text\n\n\ndef parse_sympy_expression(text: Text):\n    normalized = text.replace("^", "**")\n    return parse_expr(normalized, transformations=TRANSFORMATIONS, evaluate=True)\n\n\ndef format_sympy_expr(expr) -> str:\n    return str(expr).replace("**", "^")\n\n\ndef parse_scale_ratio(text: Text) -> Optional[Tuple[float, float]]:\n    match = re.search(r"(\\d+(?:[.,]\\d+)?)\\s*:\\s*(\\d+(?:[.,]\\d+)?)", text)\n    if not match:\n        return None\n    left = float(match.group(1).replace(",", "."))\n    right = float(match.group(2).replace(",", "."))\n    return left, right\n\n\ndef parse_lengths_with_units(text: Text) -> List[Tuple[float, str, float]]:\n    unit_map = {\n        "см": 1.0,\n        "cm": 1.0,\n        "м": 100.0,\n        "метр": 100.0,\n        "км": 100000.0,\n    }\n    results: List[Tuple[float, str, float]] = []\n    for value_str, unit in re.findall(\n        r"(-?\\d+(?:[.,]\\d+)?)\\s*(см|cm|м|метр|км)", text, flags=re.IGNORECASE\n    ):\n        value = float(value_str.replace(",", "."))\n        unit_lower = unit.lower()\n        cm_value = value * unit_map[unit_lower]\n        results.append((value, unit_lower, cm_value))\n    return results\n\n\ndef format_pi_value(coef: float) -> str:\n    coef_text = format_number(coef)\n    if coef_text == "0":\n        return "0"\n    if coef_text == "1":\n        return "pi"\n    return f"{coef_text}*pi"\n\n\nclass ActionSolveQuadratic(Action):\n    def name(self) -> Text:\n        return "action_solve_quadratic"\n\n    def run(\n        self,\n        dispatcher: CollectingDispatcher,\n        tracker: Tracker,\n        domain: Dict[Text, Any],\n    ) -> List[Dict[Text, Any]]:\n        text = tracker.latest_message.get("text", "")\n        coeffs = parse_quadratic_coeffs(text)\n        if coeffs is None:\n            dispatcher.utter_message(\n                text="a, b, c коэффициентээ өгнө үү. Жишээ: квадрат тэгшитгэл бод 1 -3 2"\n            )\n            return []\n        a, b, c = coeffs\n\n        if abs(a) < EPSILON:\n            if abs(b) < EPSILON:\n                if abs(c) < EPSILON:\n                    dispatcher.utter_message(\n                        text="0 = 0 тул хязгааргүй олон шийдтэй."\n                    )\n                else:\n                    dispatcher.utter_message(\n                        text="0x + c = 0 хэлбэр тул шийдгүй."\n                    )\n                return []\n            x = -c / b\n            dispatcher.utter_message(\n                text=f"a=0 тул шугаман тэгшитгэл. x = {format_number(x)}"\n            )\n            return []\n\n        d = b * b - 4 * a * c\n        dispatcher.utter_message(text="Томьёо: x = (-b +/- sqrt(D)) / (2a)")\n        dispatcher.utter_message(text=f"D = b^2 - 4ac = {format_number(d)}")\n\n        if d > EPSILON:\n            sqrt_d = math.sqrt(d)\n            x1 = (-b + sqrt_d) / (2 * a)\n            x2 = (-b - sqrt_d) / (2 * a)\n            dispatcher.utter_message(\n                text=(\n                    "Хоёр бодит шийд: "\n                    f"x1 = {format_number(x1)}, x2 = {format_number(x2)}"\n                )\n            )\n        elif abs(d) <= EPSILON:\n            x = -b / (2 * a)\n            dispatcher.utter_message(text=f"Давхар шийд: x = {format_number(x)}")\n        else:\n            dispatcher.utter_message(text="D < 0 тул бодит шийдгүй.")\n            dispatcher.utter_message(\n                text="Хэрэв комплекс авч үзвэл: x = (-b +/- i*sqrt(|D|)) / (2a)"\n            )\n        return []\n\n\nclass ActionDiscriminant(Action):\n    def name(self) -> Text:\n        return "action_discriminant"\n\n    def run(\n        self,\n        dispatcher: CollectingDispatcher,\n        tracker: Tracker,\n        domain: Dict[Text, Any],\n    ) -> List[Dict[Text, Any]]:\n        text = tracker.latest_message.get("text", "")\n        text_lower = text.lower()\n        coeffs = parse_quadratic_coeffs(text)\n        if coeffs is None:\n            if "томьёо" in text_lower or "гэж юу" in text_lower:\n                dispatcher.utter_message(\n                    text="Дискриминант: D = b^2 - 4ac. D>0 бол 2 бодит шийд, D=0 бол 1 давхар шийд, D<0 бол бодит шийдгүй."\n                )\n                return []\n            dispatcher.utter_message(\n                text="a, b, c-гээ өгнө үү. Жишээ: дискриминант ол 1 -3 2"\n            )\n            return []\n        a, b, c = coeffs\n        d = b * b - 4 * a * c\n        if abs(a) < EPSILON:\n            dispatcher.utter_message(\n                text="a=0 тул квадрат тэгшитгэл биш боловч D = b^2 - 4ac томьёогоор тооцлоо."\n            )\n        dispatcher.utter_message(text=f"D = b^2 - 4ac = {format_number(d)}")\n        if d > EPSILON:\n            dispatcher.utter_message(text="D > 0 тул 2 бодит шийдтэй.")\n        elif abs(d) <= EPSILON:\n            dispatcher.utter_message(text="D = 0 тул 1 давхар шийдтэй.")\n        else:\n            dispatcher.utter_message(text="D < 0 тул бодит шийдгүй.")\n        return []\n\n\nclass ActionFactorOrExpand(Action):\n    def name(self) -> Text:\n        return "action_factor_or_expand"\n\n    def run(\n        self,\n        dispatcher: CollectingDispatcher,\n        tracker: Tracker,\n        domain: Dict[Text, Any],\n    ) -> List[Dict[Text, Any]]:\n        text = tracker.latest_message.get("text", "")\n        text_lower = text.lower()\n        expand_mode = any(word in text_lower for word in ("дэлг", "expand"))\n\n        expr_text = extract_expression(text)\n        if not expr_text:\n            dispatcher.utter_message(\n                text="Илэрхийлэл өгнө үү. Жишээ: x^2-5x+6 -г факторчил, эсвэл (x+3)(x-2) -г дэлгэж өг"\n            )\n            return []\n        try:\n            expr = parse_sympy_expression(expr_text)\n        except Exception:\n            dispatcher.utter_message(text="Илэрхийлэл танигдсангүй. Жишээ: 2x^2+5x+3")\n            return []\n\n        if expand_mode:\n            result = expand(expr)\n            dispatcher.utter_message(\n                text=f"Дэлгэсэн хэлбэр: {format_sympy_expr(result)}"\n            )\n        else:\n            result = factor(expr)\n            dispatcher.utter_message(\n                text=f"Факторчилсон хэлбэр: {format_sympy_expr(result)}"\n            )\n        return []\n\n\nclass ActionSimilarityScale(Action):\n    def name(self) -> Text:\n        return "action_similarity_scale"\n\n    def run(\n        self,\n        dispatcher: CollectingDispatcher,\n        tracker: Tracker,\n        domain: Dict[Text, Any],\n    ) -> List[Dict[Text, Any]]:\n        text = tracker.latest_message.get("text", "")\n        text_lower = text.lower()\n\n        if "периметр" in text_lower and ("харьцаа" in text_lower or "харьцаатай" in text_lower):\n            numbers = parse_numbers(text_lower)\n            if len(numbers) >= 2:\n                a, b = numbers[-2], numbers[-1]\n                dispatcher.utter_message(\n                    text=f"Периметрүүдийн харьцаа талуудын адил: {format_number(a)}:{format_number(b)}"\n                )\n                return []\n\n        if "талбай" in text_lower and "масштаб" in text_lower:\n            numbers = parse_numbers(text_lower)\n            if numbers:\n                area_factor = numbers[0]\n                scale = math.sqrt(area_factor)\n                dispatcher.utter_message(\n                    text=f"Талбай k^2-оор өснө. k = sqrt({format_number(area_factor)}) = {format_number(scale)}"\n                )\n                return []\n\n        if "урт" in text_lower and "эзэлхүүн" in text_lower:\n            numbers = parse_numbers(text_lower)\n            if numbers:\n                length_factor = numbers[0]\n                volume_factor = length_factor ** 3\n                dispatcher.utter_message(\n                    text=f"Эзэлхүүн k^3-оор өөрчлөгдөнө: {format_number(volume_factor)} дахин."\n                )\n                return []\n\n        if "томруул" in text_lower and "масштаб" in text_lower:\n            numbers = parse_numbers(text_lower)\n            if numbers:\n                factor = numbers[0]\n                dispatcher.utter_message(\n                    text=f"Масштаб = {format_number(factor)}:1 (эсвэл 1:{format_number(1 / factor)})"\n                )\n                return []\n\n        if "масштаб" in text_lower and ("ол" in text_lower or "хэд" in text_lower) and "1:" not in text_lower:\n            lengths = parse_lengths_with_units(text_lower)\n            if len(lengths) >= 2:\n                map_cm = lengths[0][2]\n                real_cm = lengths[1][2]\n                if map_cm > EPSILON:\n                    scale = real_cm / map_cm\n                    dispatcher.utter_message(\n                        text=f"Масштаб = 1:{format_number(scale)}"\n                    )\n                    return []\n\n        ratio = parse_scale_ratio(text_lower)\n        lengths = parse_lengths_with_units(text_lower)\n        if ratio and lengths:\n            left, right = ratio\n            if abs(left) < EPSILON:\n                dispatcher.utter_message(text="Масштабын зүүн тал 0 байж болохгүй.")\n                return []\n            map_cm = lengths[0][2]\n            real_cm = map_cm * (right / left)\n            if "км" in text_lower:\n                km = real_cm / 100000.0\n                dispatcher.utter_message(text=f"Бодит зай: {format_number(km)} км")\n                return []\n            if "метр" in text_lower:\n                meters = real_cm / 100.0\n                dispatcher.utter_message(text=f"Бодит зай: {format_number(meters)} м")\n                return []\n            dispatcher.utter_message(\n                text=f"Бодит зай: {format_number(real_cm)} см = {format_number(real_cm / 100.0)} м"\n            )\n            return []\n\n        if "масштаб" in text_lower:\n            match_ab = re.search(r"ab\\s*=\\s*(-?\\d+(?:[.,]\\d+)?)", text_lower)\n            match_apb = re.search(\n                r"a[\'’]b[\'’]\\s*=\\s*(-?\\d+(?:[.,]\\d+)?)", text_lower\n            )\n            if match_ab and match_apb:\n                ab = float(match_ab.group(1).replace(",", "."))\n                apb = float(match_apb.group(1).replace(",", "."))\n                if abs(ab) > EPSILON:\n                    scale = apb / ab\n                    dispatcher.utter_message(\n                        text=f"Масштаб k = {format_number(scale)}"\n                    )\n                    return []\n\n        dispatcher.utter_message(\n            text="Төсөө/масштаб: уртын харьцаа k, талбай k^2, эзэлхүүн k^3. Жишээ: масштаб 1:500 дээр 4см нь бодит хэд вэ?"\n        )\n        return []\n\n\nclass ActionProbability(Action):\n    def name(self) -> Text:\n        return "action_probability"\n\n    def run(\n        self,\n        dispatcher: CollectingDispatcher,\n        tracker: Tracker,\n        domain: Dict[Text, Any],\n    ) -> List[Dict[Text, Any]]:\n        text = tracker.latest_message.get("text", "")\n        text_lower = text.lower()\n\n        if "шоо" in text_lower:\n            two_times = ("2" in text_lower or "хоёр" in text_lower) and "удаа" in text_lower\n            if two_times and "6" in text_lower:\n                dispatcher.utter_message(text=f"P = {format_fraction(1, 36)}")\n                return []\n            if "6" in text_lower:\n                dispatcher.utter_message(text=f"P = {format_fraction(1, 6)}")\n                return []\n\n        if "зос" in text_lower and ("3" in text_lower or "гурав" in text_lower):\n            if ("2" in text_lower or "хоёр" in text_lower) and "сүлд" in text_lower:\n                dispatcher.utter_message(text=f"P = {format_fraction(3, 8)}")\n                return []\n\n        if "улаан" in text_lower and "цэнхэр" in text_lower:\n            red_match = re.search(r"(\\d+)\\s*улаан", text_lower)\n            blue_match = re.search(r"(\\d+)\\s*цэнхэр", text_lower)\n            red = int(red_match.group(1)) if red_match else 3\n            blue = int(blue_match.group(1)) if blue_match else 2\n            total = red + blue\n            if "буцаахгүй" in text_lower and "цэнхэр" in text_lower:\n                dispatcher.utter_message(\n                    text=f"P = {format_fraction(blue, total)} (өөрчлөхгүй гэж үзэв)"\n                )\n                return []\n            if "улаан" in text_lower and "магадлал" in text_lower and "цэнхэр гарах" not in text_lower:\n                dispatcher.utter_message(text=f"P = {format_fraction(red, total)}")\n                return []\n            if "цэнхэр" in text_lower and "магадлал" in text_lower:\n                dispatcher.utter_message(text=f"P = {format_fraction(blue, total)}")\n                return []\n\n        dispatcher.utter_message(\n            text="Магадлал: P(A)=таатай/нийт. Жишээ: шоо нэг шидэхэд 6 буух магадлал хэд вэ?"\n        )\n        return []\n\n\nclass ActionStatistics(Action):\n    def name(self) -> Text:\n        return "action_statistics"\n\n    def run(\n        self,\n        dispatcher: CollectingDispatcher,\n        tracker: Tracker,\n        domain: Dict[Text, Any],\n    ) -> List[Dict[Text, Any]]:\n        text = tracker.latest_message.get("text", "")\n        text_lower = text.lower()\n        numbers = parse_numbers(text)\n        if not numbers:\n            if "суурь" in text_lower or "үндэс" in text_lower:\n                dispatcher.utter_message(\n                    text="Статистик: дундаж, медиан, мод, хүрээ, дисперс зэрэг үзүүлэлтүүдтэй."\n                )\n                return []\n            dispatcher.utter_message(\n                text="Өгөгдлөө өгнө үү. Жишээ: дундаж ол 2 4 6 8 10"\n            )\n            return []\n\n        if "дундаж" in text_lower:\n            mean = sum(numbers) / len(numbers)\n            dispatcher.utter_message(text=f"Дундаж = {format_number(mean)}")\n            return []\n\n        if "медиан" in text_lower:\n            nums = sorted(numbers)\n            n = len(nums)\n            if n % 2 == 1:\n                median = nums[n // 2]\n            else:\n                median = (nums[n // 2 - 1] + nums[n // 2]) / 2\n            dispatcher.utter_message(text=f"Медиан = {format_number(median)}")\n            return []\n\n        if "мод" in text_lower:\n            freq: Dict[float, int] = {}\n            for num in numbers:\n                freq[num] = freq.get(num, 0) + 1\n            max_count = max(freq.values())\n            modes = [num for num, count in freq.items() if count == max_count]\n            mode_text = ", ".join(format_number(num) for num in sorted(modes))\n            dispatcher.utter_message(text=f"Мод = {mode_text}")\n            return []\n\n        if "хүрээ" in text_lower or "range" in text_lower:\n            data_range = max(numbers) - min(numbers)\n            dispatcher.utter_message(text=f"Хүрээ = {format_number(data_range)}")\n            return []\n\n        if "дисперс" in text_lower:\n            mean = sum(numbers) / len(numbers)\n            variance = sum((x - mean) ** 2 for x in numbers) / len(numbers)\n            dispatcher.utter_message(\n                text=f"Дисперс (суурь, n-т хуваасан) = {format_number(variance)}"\n            )\n            return []\n\n        dispatcher.utter_message(\n            text="Статистикийн төрөл танигдсангүй (дундаж/медиан/мод/хүрээ/дисперс)."\n        )\n        return []\n\n\nclass ActionTrigonometry(Action):\n    def name(self) -> Text:\n        return "action_trigonometry"\n\n    def run(\n        self,\n        dispatcher: CollectingDispatcher,\n        tracker: Tracker,\n        domain: Dict[Text, Any],\n    ) -> List[Dict[Text, Any]]:\n        text = tracker.latest_message.get("text", "")\n        text_lower = text.lower()\n\n        if "sin^2" in text_lower and "cos^2" in text_lower:\n            dispatcher.utter_message(\n                text="sin^2(x) + cos^2(x) = 1 нь нэгж тойргийн үндсэн адилтгал."\n            )\n            return []\n\n        if "радиан" in text_lower and "градус" in text_lower:\n            if "pi" in text_lower or "π" in text:\n                match = re.search(r"(\\d+)?\\s*(pi|π)\\s*/\\s*(\\d+)", text_lower)\n                if match:\n                    numerator = int(match.group(1) or "1")\n                    denominator = int(match.group(3))\n                    degrees = 180 * numerator / denominator\n                    if numerator == 1:\n                        rad_text = f"pi/{denominator}"\n                    else:\n                        rad_text = f"{numerator}*pi/{denominator}"\n                    dispatcher.utter_message(\n                        text=f"{rad_text} радиан = {format_number(degrees)} градус"\n                    )\n                    return []\n            match = re.search(r"(-?\\d+(?:[.,]\\d+)?)\\s*градус", text_lower)\n            if match:\n                deg = float(match.group(1).replace(",", "."))\n                exact = {\n                    30: "pi/6",\n                    45: "pi/4",\n                    60: "pi/3",\n                    90: "pi/2",\n                    180: "pi",\n                    135: "3*pi/4",\n                    150: "5*pi/6",\n                }\n                if deg in exact:\n                    dispatcher.utter_message(\n                        text=f"{format_number(deg)} градус = {exact[deg]} радиан"\n                    )\n                else:\n                    rad = deg * math.pi / 180\n                    dispatcher.utter_message(\n                        text=f"{format_number(deg)} градус = {format_number(rad)} радиан"\n                    )\n                return []\n\n        sin_values = {0: "0", 30: "1/2", 90: "1", 150: "1/2"}\n        cos_values = {0: "1", 60: "1/2", 180: "-1"}\n        tan_values = {45: "1", 135: "-1"}\n\n        if "sin" in text_lower:\n            angles = [int(a) for a in re.findall(r"sin\\s*\\(?\\s*(\\d+)", text_lower)]\n            if "pi/6" in text_lower or "π/6" in text:\n                dispatcher.utter_message(text="sin(pi/6) = 1/2")\n                return []\n            if angles:\n                parts = []\n                for angle in angles:\n                    value = sin_values.get(angle)\n                    if value is None:\n                        value = format_number(math.sin(math.radians(angle)))\n                    parts.append(f"sin {angle} = {value}")\n                dispatcher.utter_message(text=", ".join(parts))\n                return []\n\n        if "cos" in text_lower:\n            angles = [int(a) for a in re.findall(r"cos\\s*\\(?\\s*(\\d+)", text_lower)]\n            if "pi/3" in text_lower or "π/3" in text:\n                dispatcher.utter_message(text="cos(pi/3) = 1/2")\n                return []\n            if angles:\n                parts = []\n                for angle in angles:\n                    value = cos_values.get(angle)\n                    if value is None:\n                        value = format_number(math.cos(math.radians(angle)))\n                    parts.append(f"cos {angle} = {value}")\n                dispatcher.utter_message(text=", ".join(parts))\n                return []\n\n        if "tan" in text_lower:\n            angles = [int(a) for a in re.findall(r"tan\\s*\\(?\\s*(\\d+)", text_lower)]\n            if angles:\n                parts = []\n                for angle in angles:\n                    if angle == 90:\n                        value = "тодорхойгүй"\n                    else:\n                        value = tan_values.get(angle)\n                        if value is None:\n                            value = format_number(math.tan(math.radians(angle)))\n                    parts.append(f"tan {angle} = {value}")\n                dispatcher.utter_message(text=", ".join(parts))\n                return []\n\n        dispatcher.utter_message(\n            text="Суурь томьёо: sin=эсрэг/гипотенуз, cos=залгаа/гипотенуз, tan=эсрэг/залгаа. Жишээ: sin 30, cos 60, tan 45."\n        )\n        return []\n\n\nclass ActionSquareRoots(Action):\n    def name(self) -> Text:\n        return "action_square_roots"\n\n    def run(\n        self,\n        dispatcher: CollectingDispatcher,\n        tracker: Tracker,\n        domain: Dict[Text, Any],\n    ) -> List[Dict[Text, Any]]:\n        text = tracker.latest_message.get("text", "")\n        text_lower = text.lower()\n\n        expr_text = extract_expression(text, allow_sqrt=True)\n        if not expr_text:\n            dispatcher.utter_message(\n                text="Квадрат язгуур: a^2 = a*a, sqrt(a^2)=|a|. Жишээ: √50, √72, 1/√5"\n            )\n            return []\n        expr_text = normalize_sqrt_text(expr_text)\n\n        try:\n            expr = parse_sympy_expression(expr_text)\n        except Exception:\n            dispatcher.utter_message(text="Язгуурын илэрхийлэл танигдсангүй.")\n            return []\n\n        if "язгуургүй" in text_lower or "rationalize" in text_lower:\n            result = radsimp(expr)\n            dispatcher.utter_message(text=f"Хариу: {format_sympy_expr(result)}")\n            return []\n\n        result = simplify(expr)\n        if result.has(I):\n            dispatcher.utter_message(\n                text="Бодит тоонд боломжгүй. Комплекс тоонд: "\n                f"{format_sympy_expr(result)}"\n            )\n            return []\n        dispatcher.utter_message(text=f"Хариу: {format_sympy_expr(result)}")\n        return []\n\n\nclass ActionCone(Action):\n    def name(self) -> Text:\n        return "action_cone"\n\n    def run(\n        self,\n        dispatcher: CollectingDispatcher,\n        tracker: Tracker,\n        domain: Dict[Text, Any],\n    ) -> List[Dict[Text, Any]]:\n        text = tracker.latest_message.get("text", "")\n        text_lower = text.lower()\n\n        def extract_value(patterns: List[str]) -> Optional[float]:\n            for pattern in patterns:\n                match = re.search(pattern, text_lower)\n                if match:\n                    return float(match.group(1).replace(",", "."))\n            return None\n\n        r_value = extract_value([r"\\br\\s*[:=]\\s*(-?\\d+(?:[.,]\\d+)?)", r"радиус\\s*(-?\\d+(?:[.,]\\d+)?)"])\n        h_value = extract_value([r"\\bh\\s*[:=]\\s*(-?\\d+(?:[.,]\\d+)?)", r"өндөр\\s*(-?\\d+(?:[.,]\\d+)?)"])\n        l_value = extract_value([r"\\bl\\s*[:=]\\s*(-?\\d+(?:[.,]\\d+)?)", r"ташуу\\s*[-\\w]*\\s*(-?\\d+(?:[.,]\\d+)?)"])\n        d_value = extract_value([r"диаметр\\s*(-?\\d+(?:[.,]\\d+)?)", r"\\bd\\s*[:=]\\s*(-?\\d+(?:[.,]\\d+)?)"])\n\n        if "бөмбөрцөг" in text_lower and "конус" in text_lower and not any(\n            word in text_lower for word in ("r=", "h=", "l=", "диаметр")\n        ):\n            dispatcher.utter_message(\n                text=(\n                    "Конус: V = (1/3)*pi*r^2*h, l = sqrt(r^2 + h^2), "\n                    "Sx = pi*r*l, S = pi*r^2 + pi*r*l. "\n                    "Бөмбөрцөг: S = 4*pi*r^2, V = (4/3)*pi*r^3."\n                )\n            )\n            return []\n\n        if "байгуулагч" in text_lower or "ташуу" in text_lower:\n            if r_value is not None and h_value is not None:\n                l_calc = math.sqrt(r_value ** 2 + h_value ** 2)\n                dispatcher.utter_message(\n                    text=f"l = sqrt(r^2 + h^2) = {format_number(l_calc)}"\n                )\n                return []\n            dispatcher.utter_message(\n                text="l = sqrt(r^2 + h^2) томьёогоор олно. r, h-ийг өгнө үү."\n            )\n            return []\n\n        if "хажуу" in text_lower:\n            if r_value is not None and l_value is not None:\n                coef = r_value * l_value\n                dispatcher.utter_message(\n                    text=f"Sx = pi*r*l = {format_pi_value(coef)} (~{format_number(coef * math.pi)})"\n                )\n                return []\n            dispatcher.utter_message(\n                text="Хажуу гадаргуу: Sx = pi*r*l. r, l-ийг өгнө үү."\n            )\n            return []\n\n        if "нийт" in text_lower:\n            if r_value is not None and l_value is not None:\n                coef = r_value ** 2 + r_value * l_value\n                dispatcher.utter_message(\n                    text=f"S = pi*(r^2 + r*l) = {format_pi_value(coef)} (~{format_number(coef * math.pi)})"\n                )\n                return []\n            dispatcher.utter_message(\n                text="Нийт гадаргуу: S = pi*r^2 + pi*r*l. r, l-ийг өгнө үү."\n            )\n            return []\n\n        if "эзэлхүүн" in text_lower or "v" in text_lower:\n            if r_value is None and d_value is not None:\n                r_value = d_value / 2\n            if r_value is not None and h_value is not None:\n                coef = (r_value ** 2 * h_value) / 3\n                dispatcher.utter_message(\n                    text=f"V = (1/3)*pi*r^2*h = {format_pi_value(coef)} (~{format_number(coef * math.pi)})"\n                )\n                return []\n            dispatcher.utter_message(\n                text="Эзэлхүүн: V = (1/3)*pi*r^2*h. r, h (эсвэл диаметр, өндөр)-ийг өгнө үү."\n            )\n            return []\n\n        dispatcher.utter_message(\n            text="Конусын томьёо: V=(1/3)*pi*r^2*h, l=sqrt(r^2+h^2), Sx=pi*r*l, S=pi*r^2+pi*r*l."\n        )\n        return []\n\n\nclass ActionSphere(Action):\n    def name(self) -> Text:\n        return "action_sphere"\n\n    def run(\n        self,\n        dispatcher: CollectingDispatcher,\n        tracker: Tracker,\n        domain: Dict[Text, Any],\n    ) -> List[Dict[Text, Any]]:\n        text = tracker.latest_message.get("text", "")\n        text_lower = text.lower()\n\n        def extract_value(patterns: List[str]) -> Optional[float]:\n            for pattern in patterns:\n                match = re.search(pattern, text_lower)\n                if match:\n                    return float(match.group(1).replace(",", "."))\n            return None\n\n        r_value = extract_value([r"\\br\\s*[:=]\\s*(-?\\d+(?:[.,]\\d+)?)", r"радиус\\s*(-?\\d+(?:[.,]\\d+)?)"])\n        d_value = extract_value([r"диаметр\\s*(-?\\d+(?:[.,]\\d+)?)", r"\\bd\\s*[:=]\\s*(-?\\d+(?:[.,]\\d+)?)"])\n\n        v_match = re.search(r"v\\s*=\\s*(-?\\d+(?:[.,]\\d+)?)\\s*(pi|π)", text_lower)\n        if v_match and ("r ол" in text_lower or "радиус" in text_lower):\n            coef = float(v_match.group(1).replace(",", "."))\n            r_calc = (3 * coef / 4) ** (1 / 3)\n            dispatcher.utter_message(\n                text=f"V = (4/3)*pi*r^3 => r = {format_number(r_calc)}"\n            )\n            return []\n\n        if r_value is None and d_value is not None:\n            r_value = d_value / 2\n\n        if "эзэлхүүн" in text_lower or "v" in text_lower:\n            if r_value is not None:\n                coef = (4 * r_value ** 3) / 3\n                dispatcher.utter_message(\n                    text=f"V = (4/3)*pi*r^3 = {format_pi_value(coef)} (~{format_number(coef * math.pi)})"\n                )\n                return []\n            dispatcher.utter_message(\n                text="Эзэлхүүн: V = (4/3)*pi*r^3. r (эсвэл диаметр)-ийг өгнө үү."\n            )\n            return []\n\n        if "гадаргуу" in text_lower:\n            if r_value is not None:\n                coef = 4 * r_value ** 2\n                dispatcher.utter_message(\n                    text=f"S = 4*pi*r^2 = {format_pi_value(coef)} (~{format_number(coef * math.pi)})"\n                )\n                return []\n            dispatcher.utter_message(text="Гадаргуу: S = 4*pi*r^2. r-ийг өгнө үү.")\n            return []\n\n        dispatcher.utter_message(\n            text="Бөмбөрцөг: S = 4*pi*r^2, V = (4/3)*pi*r^3."\n        )\n        return []\n'
_mod_6 = _load_module('_actions_part_6_grade_7_9_part3_actions', _SRC_6)

# Expose Action / FormValidationAction subclasses to Rasa SDK
try:
    from rasa_sdk import Action
    from rasa_sdk.forms import FormValidationAction
except Exception:
    Action = object  # type: ignore
    FormValidationAction = object  # type: ignore

_seen = set()
for _m in [    _mod_1,    _mod_2,    _mod_3,    _mod_4,    _mod_5,    _mod_6,]:
    for _name, _obj in list(_m.__dict__.items()):
        if isinstance(_obj, type) and (issubclass(_obj, Action) or issubclass(_obj, FormValidationAction)):
            # Avoid overwriting by variable name; action registration uses name() method.
            key = (_m.__name__, _name)
            if key in _seen:
                continue
            _seen.add(key)
            gname = _name
            if gname in globals():
                gname = f"{_m.__name__.replace('.', '_')}_{_name}"
            globals()[gname] = _obj


class ActionHandleOutOfScope(Action):
    def name(self) -> str:
        return "action_handle_out_of_scope"

    def run(self, dispatcher, tracker, domain):
        pending_topic = tracker.get_slot("pending_topic")
        if pending_topic == "integral":
            return ActionIntegral().run(dispatcher, tracker, domain)
        if pending_topic == "function_analysis":
            return ActionFunctionAnalysis().run(dispatcher, tracker, domain)
        if pending_topic == "derivative":
            return ActionDerivative().run(dispatcher, tracker, domain)
        if pending_topic == "logarithm":
            return ActionLogarithm().run(dispatcher, tracker, domain)
        if tracker.get_slot("pending_calc"):
            return ActionHandleMeasurements().run(dispatcher, tracker, domain)
        dispatcher.utter_message(response="utter_out_of_scope")
        return []

import re
from typing import Optional


def _guess_diff_var(text: str) -> str:
    lowered = text.lower()
    for var in ("x", "y", "z", "t"):
        if f"d{var}" in lowered:
            return var
    return "x"


def _strip_math_text(text: str) -> str:
    allowed = set("0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ+-*/^().")
    return "".join(ch if ch in allowed else " " for ch in text)


def _extract_integral_expression(text: str) -> Optional[str]:
    cleaned = text.replace("∫", " ")
    cleaned = cleaned.replace("π", "pi")
    cleaned = re.sub(r"\b(integral|интегралл|интеграл)\b", " ", cleaned, flags=re.IGNORECASE)
    cleaned = re.sub(r"d\s*[xyzt]\b", " ", cleaned, flags=re.IGNORECASE)
    cleaned = _strip_math_text(cleaned)
    expr = cleaned.replace(" ", "").rstrip("+-*/^")
    return expr or None


def _extract_function_expression(text: str) -> Optional[str]:
    match = re.search(r"(?:f\(x\)|y)\s*=\s*(.+)", text, flags=re.IGNORECASE)
    expr_raw = match.group(1) if match else text
    expr_raw = expr_raw.replace("π", "pi")
    cleaned = _strip_math_text(expr_raw)
    expr = cleaned.replace(" ", "").rstrip("+-*/^")
    return expr or None


def _extract_log_expression(text: str) -> Optional[str]:
    cleaned = text.replace("π", "pi")
    cleaned = re.sub(
        r"\b(логарифм|logarithm)\b",
        " ",
        cleaned,
        flags=re.IGNORECASE,
    )
    cleaned = cleaned.replace("ln", "log").replace("lg", "log")
    match = re.search(
        r"(\d+(?:[.,]\d+)?)\s*(?:суурь|base)\s*(\d+(?:[.,]\d+)?)",
        cleaned,
        flags=re.IGNORECASE,
    )
    if match:
        value = match.group(1).replace(",", ".")
        base = match.group(2).replace(",", ".")
        return f"log({value},{base})"
    match = re.search(
        r"(?:суурь|base)\s*(\d+(?:[.,]\d+)?)\s*(?:лог|log)\s*(\d+(?:[.,]\d+)?)",
        cleaned,
        flags=re.IGNORECASE,
    )
    if match:
        base = match.group(1).replace(",", ".")
        value = match.group(2).replace(",", ".")
        return f"log({value},{base})"
    match = re.search(
        r"log_\s*([0-9a-zA-Z.+-]+)\s*\(?\s*([^\s)]+)\s*\)?",
        cleaned,
        flags=re.IGNORECASE,
    )
    if match:
        base = match.group(1)
        value = match.group(2)
        return f"log({value},{base})"
    match = re.search(
        r"log\s*([0-9]+)\s*\(?\s*([^\s)]+)\s*\)?",
        cleaned,
        flags=re.IGNORECASE,
    )
    if match:
        base = match.group(1)
        value = match.group(2)
        return f"log({value},{base})"
    match = re.search(
        r"\blog\s*([0-9a-zA-Z.+-]+)\b",
        cleaned,
        flags=re.IGNORECASE,
    )
    if match and "log(" not in cleaned:
        value = match.group(1)
        return f"log({value})"
    allowed = set("0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ+-*/^().,")
    cleaned = "".join(ch if ch in allowed else " " for ch in cleaned)
    expr = cleaned.replace(" ", "").rstrip("+-*/^,")
    return expr or None


def _extract_derivative_expression(text: str) -> Optional[str]:
    cleaned = text.replace("′", "'").replace("’", "'")
    cleaned = re.sub(r"d\s*/\s*d\s*[xyzt]", " ", cleaned, flags=re.IGNORECASE)
    cleaned = re.sub(
        r"\b(derivative|differentiate|diff|differentiation|уламжлал|дифференциалл?|дифф)\b",
        " ",
        cleaned,
        flags=re.IGNORECASE,
    )
    cleaned = re.sub(r"f\s*'\s*\(\s*[xyzt]\s*\)", " ", cleaned, flags=re.IGNORECASE)
    return _extract_function_expression(cleaned)


class ActionIntegral(Action):
    def name(self) -> str:
        return "action_integral"

    def run(self, dispatcher, tracker, domain):
        from sympy import Symbol, integrate
        from rasa_sdk.events import SlotSet

        text = tracker.latest_message.get("text", "")
        slot_expr = tracker.get_slot("integral_expr")
        expr_text = _extract_integral_expression(text)
        if not expr_text and slot_expr:
            expr_text = _extract_integral_expression(slot_expr) or slot_expr
        if not expr_text:
            dispatcher.utter_message(response="utter_ask_integral_expr")
            return [
                SlotSet("pending_topic", "integral"),
                SlotSet("pending_calc", None),
                SlotSet("integral_expr", None),
            ]

        var_name = _guess_diff_var(text)
        try:
            expr = _mod_4.parse_sympy_expression(expr_text)
        except Exception:
            dispatcher.utter_message(
                text="Интегралын илэрхийлэл танигдсангүй. Жишээ: ∫(2x+3) dx"
            )
            return [
                SlotSet("pending_topic", "integral"),
                SlotSet("pending_calc", None),
                SlotSet("integral_expr", None),
            ]

        try:
            result = integrate(expr, Symbol(var_name))
        except Exception:
            dispatcher.utter_message(
                text="Интеграл бодоход алдаа гарлаа. Илэрхийллээ шалгаад дахин оролдоорой."
            )
            return [
                SlotSet("pending_topic", "integral"),
                SlotSet("pending_calc", None),
                SlotSet("integral_expr", None),
            ]

        expr_fmt = _mod_4.format_sympy_expr(expr)
        result_fmt = _mod_4.format_sympy_expr(result).replace("log(", "ln(")
        dispatcher.utter_message(
            text=f"∫ {expr_fmt} d{var_name} = {result_fmt} + C"
        )
        return [
            SlotSet("pending_topic", None),
            SlotSet("pending_calc", None),
            SlotSet("integral_expr", None),
        ]


class ActionFunctionAnalysis(Action):
    def name(self) -> str:
        return "action_function_analysis"

    def run(self, dispatcher, tracker, domain):
        from sympy import Symbol, diff, solve
        from rasa_sdk.events import SlotSet

        text = tracker.latest_message.get("text", "")
        slot_expr = tracker.get_slot("function_expr")
        expr_text = _extract_function_expression(text)
        if not expr_text and slot_expr:
            expr_text = _extract_function_expression(slot_expr) or slot_expr
        if not expr_text:
            dispatcher.utter_message(response="utter_ask_function_expr")
            return [
                SlotSet("pending_topic", "function_analysis"),
                SlotSet("pending_calc", None),
                SlotSet("function_expr", None),
            ]

        try:
            expr = _mod_4.parse_sympy_expression(expr_text)
        except Exception:
            dispatcher.utter_message(
                text="Функцийн илэрхийлэл танигдсангүй. Жишээ: f(x)=x^2-3x+2"
            )
            return [
                SlotSet("pending_topic", "function_analysis"),
                SlotSet("pending_calc", None),
                SlotSet("function_expr", None),
            ]

        x = Symbol("x")
        d1 = diff(expr, x)
        d2 = diff(d1, x)

        dispatcher.utter_message(text=f"f(x) = {_mod_4.format_sympy_expr(expr)}")
        dispatcher.utter_message(text=f"f'(x) = {_mod_4.format_sympy_expr(d1)}")
        dispatcher.utter_message(text=f"f''(x) = {_mod_4.format_sympy_expr(d2)}")

        try:
            roots = solve(d1, x)
        except Exception:
            roots = []

        if roots:
            roots_list = list(roots)
            real_roots = [r for r in roots_list if getattr(r, "is_real", None) is not False]
            use_roots = real_roots or roots_list
            roots_text = ", ".join(_mod_4.format_sympy_expr(r) for r in use_roots)
            dispatcher.utter_message(text=f"f'(x)=0 шийдүүд: x = {roots_text}")
        else:
            dispatcher.utter_message(
                text="f'(x)=0 шийд олдсонгүй эсвэл илэрхийлэл хэт төвөгтэй байна."
            )
        return [
            SlotSet("pending_topic", None),
            SlotSet("pending_calc", None),
            SlotSet("function_expr", None),
        ]


class ActionDerivative(Action):
    def name(self) -> str:
        return "action_derivative"

    def run(self, dispatcher, tracker, domain):
        from sympy import Symbol, diff
        from rasa_sdk.events import SlotSet

        text = tracker.latest_message.get("text", "")
        slot_expr = tracker.get_slot("derivative_expr")
        expr_text = _extract_derivative_expression(text)
        if not expr_text and slot_expr:
            expr_text = _extract_derivative_expression(slot_expr) or slot_expr
        if not expr_text:
            dispatcher.utter_message(response="utter_ask_derivative_expr")
            return [
                SlotSet("pending_topic", "derivative"),
                SlotSet("pending_calc", None),
                SlotSet("derivative_expr", None),
            ]

        var_name = _guess_diff_var(text)
        try:
            expr = _mod_4.parse_sympy_expression(expr_text)
        except Exception:
            dispatcher.utter_message(
                text="Уламжлалын илэрхийлэл танигдсангүй. Жишээ: d/dx (x^2-3x+2)"
            )
            return [
                SlotSet("pending_topic", "derivative"),
                SlotSet("pending_calc", None),
                SlotSet("derivative_expr", None),
            ]

        try:
            result = diff(expr, Symbol(var_name))
        except Exception:
            dispatcher.utter_message(
                text="Уламжлал бодоход алдаа гарлаа. Илэрхийллээ шалгаад дахин оролдоорой."
            )
            return [
                SlotSet("pending_topic", "derivative"),
                SlotSet("pending_calc", None),
                SlotSet("derivative_expr", None),
            ]

        expr_fmt = _mod_4.format_sympy_expr(expr)
        result_fmt = _mod_4.format_sympy_expr(result)
        dispatcher.utter_message(text=f"d/d{var_name} ({expr_fmt}) = {result_fmt}")
        return [
            SlotSet("pending_topic", None),
            SlotSet("pending_calc", None),
            SlotSet("derivative_expr", None),
        ]


class ActionLogarithm(Action):
    def name(self) -> str:
        return "action_logarithm"

    def run(self, dispatcher, tracker, domain):
        from sympy import simplify
        from rasa_sdk.events import SlotSet

        text = tracker.latest_message.get("text", "")
        slot_expr = tracker.get_slot("log_expr")
        expr_text = _extract_log_expression(text)
        if not expr_text and slot_expr:
            expr_text = _extract_log_expression(slot_expr) or slot_expr
        if not expr_text:
            dispatcher.utter_message(response="utter_ask_log_expr")
            return [
                SlotSet("pending_topic", "logarithm"),
                SlotSet("pending_calc", None),
                SlotSet("log_expr", None),
            ]

        try:
            expr = _mod_4.parse_sympy_expression(expr_text)
        except Exception:
            dispatcher.utter_message(
                text="Логарифмын илэрхийлэл танигдсангүй. Жишээ: ln(x), log_2(8)"
            )
            return [
                SlotSet("pending_topic", "logarithm"),
                SlotSet("pending_calc", None),
                SlotSet("log_expr", None),
            ]

        try:
            result = simplify(expr)
        except Exception:
            result = expr

        expr_fmt = _mod_4.format_sympy_expr(expr)
        result_fmt = _mod_4.format_sympy_expr(result)
        expr_fmt = re.sub(r"log\(([^,]+)\)", r"ln(\1)", expr_fmt)
        result_fmt = re.sub(r"log\(([^,]+)\)", r"ln(\1)", result_fmt)
        if expr_fmt == result_fmt:
            dispatcher.utter_message(text=f"Хариу: {result_fmt}")
        else:
            dispatcher.utter_message(text=f"{expr_fmt} = {result_fmt}")
        return [
            SlotSet("pending_topic", None),
            SlotSet("pending_calc", None),
            SlotSet("log_expr", None),
        ]
